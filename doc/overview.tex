\documentclass{article}
\usepackage[top=1in,left=1in,right=1in,bottom=1in]{geometry}
\usepackage{hyperref}
\title{Avalanche: An Event Dispatcher for SNO+\\{\it \small (as in, a lot of sno(+), very fast)}}
\author{Andy Mastbaum\footnote{\href{mailto:mastbaum@hep.upenn.edu}{mastbaum@hep.upenn.edu}}\\\small{\it The University of Pennsylvania}}
\begin{document}
\maketitle
\section{Introduction}
The ``dispatcher'' is the server software responsible for providing a stream of built events to various client software. Currently-planned client software includes the event viewer and detector monitoring tools. The dispatcher requires:

\begin{description}
\item[High Throughput] The dispatcher must be able to keep up with the maximum data rate of 450 Mbps, simultaneously to all clients.
\item[Scalability] The dispatcher should support a large number of concurrent client connections without impact on performance.
\item[Compatibility] The dispatched data stream must be reasonably language-agnostic, since the language of the client software is unknown.
\end{description}

An obvious platform choice would be ROOT's network I/O classes ({\tt TPSocket}, etc.). However, the next-generation socket library ZeroMQ\footnote{\href{http://www.zeromq.org}{http://www.zeromq.org}} provides a superior alternative. ZeroMQ is naturally asynchronous, natively supports fan-out, and implementations are typically faster than UNIX sockets. ZeroMQ's fan-out allows clients to ``subscribe'' to a stream, optionally applying a filter (e.g. only events, no run headers). Bindings exist for all major languages.

\section{Data Format}
It has been decided that the ``packed'' events coming from the event builder will be in a ROOT format, with a structure developed by G. D. Orebi Gann and J. Kaspar. The packed format preserves the ``raw'' data structures from the detector front-end: for example, charge and time data is stored in 96-bit PMT bundles. This is in contrast the `full' or `unpacked' data structure used in RAT, where values are broken into separate, histogrammable fields.

The packed data is essentially a stream of {\tt TObjects}, which may be event data, event-level headers, or run-level headers. For convenience of storage these are written to a {\tt TTree}. Since {\tt TTree}s are homogeneous lists, various data types must inherit from the same generic superclass to be stored in the tree. The data type must also be stored, so that objects can be properly re-cast when read back. The packed format {\tt TTree} stores {\tt RAT::DS::PackedRec} objects, which in turn contain a single {\tt GenericRec} and an integer {\tt RecordType}. All data types (events, headers) inherit from a class {\tt GenericRec}, which is empty and exists only to support this polymorphism.

A full listing of packed format classes and their members is given in the appendix.

\section{Network Layer}
The avalanche server broadcasts {\tt PackedRec} objects, serialized using a ROOT {\tt TBufferFile}. On the client side, software must create a {\tt TBufferFile} using the packet data, read the {\tt PackedRec} object out of it, and cast the {\tt PackedRec}'s {\tt Rec} object to the correct type based on the value of {\tt RecordType}. C++ and Python libraries to perform this deserialization are included in with avalanche, and examples in both languages are given in the {\tt examples/} directory.

\section{CouchDB Integration}
Avalanche clients may also connect to a Couch database and receive headers as they are pushed in by the DAQ. These notifications are retrieved via the CouchDB changes feed\footnote{\href{http://wiki.apache.org/couchdb/HTTP\_database\_API\#Changes}{http://wiki.apache.org/couchdb/HTTP\_database\_API\#Changes}} and the {\tt couchdb-python} Python package\footnote{\href{http://code.google.com/p/couchdb-python/}{http://code.google.com/p/couchdb-python/}}. Headers from CouchDB are interleaved with the rest of the data stream and indistinguishable from those received from an avalanche server.

\section{Dispatched Data in RAT}
Using the avalanche libraries, an input producer and output processor have been developed that allows RAT to interact with dispatched data. Simulated events may be dispatched on the network, simulating the real data flow chain, and RAT can read in dispatched events, which may be used for online processing or writing monitoring tools as RAT processors.

The code to interact with dispatched data streams was committed to SVN in r652 (git revision\\ f5387a0b495ca4b719a3a7e41487920b40f463bb). Documentation can be found in \href{https://www.snolab.ca/snoplus/private/DocDB/cgi/ShowDocument?docid=1300}{SNO+-doc-1300}.

\section{Dispatching Detector Events}
A C++ library with a very simple API is provided in the {\tt lib/cpp} directory.

A server consists of a single {\tt avalanche::server} object, constructed with a given socket address. The {\tt avalanche::server} has one method, {\tt sendObject}, which dispatches a ROOT {\tt TObject}. For example, to send a histogram {\tt TH1F* h1}:

\begin{verbatim}
 avalanche::server* serv = new avalanche::server("tcp://localhost:5024");
 serv->sendObject(h1);
\end{verbatim}
Any number of clients may be subscribed to the stream on port 5024.

\section{Writing Dispatcher Clients}
Client software connects to a stream and/or database, receives and reconstructs ROOT objects, and does something with these objects. Libraries for C++ and Python are provided in {\tt lib/} that manage the first two steps.

\subsection{C++}
{\tt libavalanche} provides a dispatcher client {\tt avalanche::client}.

Consider the following example:

\begin{verbatim}
#include <iostream>
#include <TH1F.h>
#include <RAT/DS/PackedEvent.hh>
#include <avalanche.hpp>

int main(int argc, char* argv[]) {
  // create a client, listening for objects on port 5024
  avalanche::client client("tcp://localhost:5024");

  // you can listen to an unlimited number of stream, using addServer
  client.addServer("tcp://localhost:5025");

  // receive RAT::DS::PackedRec objects
  while (1) {
    RAT::DS::PackedRec* rec = (RAT::DS::PackedRec*) client.recvObject(RAT::DS::PackedRec::Class());
    if (rec)
      std::cout << "Received PackedRec of type " << rec->RecordType << std::endl;
    else
      std::cout << "Error deserializing message data" << std::endl;
    delete rec;
  }

  return 0;
}
\end{verbatim}

First, we set up the client by giving it a server address to connect to. In this example, we also connect to one more server. You may connect to an unlimited number of streams; the packets received are interleaved, as if they arrived from one source. Next, we receive ROOT objects with {\tt recvObject}. The class must be specified for the deserialization step. Now we are ready to operate on the data. In this example we just print the record type; a real client would at this point cast the member {\tt Rec} object to the correct type, extract data, and perform some operations.

Note that {\tt recvObject} is blocking by default (it will wait until data is received). To use non-blocking I/O, provide the {\tt ZMQ\_NOBLOCK} flag as the second argument. When used in this mode, {\tt recvObject} will return {\tt NULL} when no data is available.

\subsection{Python}
The {\tt avalanche} Python package in {\tt lib/python} provides a dispatcher client {\tt avalanche.Client}. To install this package on your system, run {\tt \$ python setup.py install}.

Consider the following example:

\begin{verbatim}
import avalanche
from rat import ROOT

if __name__ == '__main__':
    # create client listening to localhost port 5024
    cli = avalanche.Client('tcp://localhost:5024')

    # you can listen to an unlimited number of stream, using add_server
    cli.add_server('tcp://localhost:5025');

    # receive RAT::DS::PackedRec objects
    while True:
        rec = cli.recv_object(ROOT.RAT.DS.PackedRec.Class())

        if rec:
            print 'Received PackedRec of type', rec.RecordType
        else:
            print 'Error deserializing message data'
\end{verbatim}
First, we set up the client by giving it a server address to connect to. In this example, we also connect to one more server. You may connect to an unlimited number of streams; the packets received are interleaved, as if they arrived from one source. Next, we receive ROOT objects with {\tt recv\_object}. The class must be specified for the deserialization step. Now we are ready to operate on the data. In this example we just print the record type; a real client would at this point cast the member {\tt Rec} object to the correct type, extract data, and perform some operations.

Note that in Python, there is no need to cast the object returned by {\tt recv\_object}, as this is taken care of by PyROOT.

As above, {\tt recv\_object} is blocking by default (waits until data is available). To use non-blocking I/O, provide the {\tt flags=zmq.NOBLOCK} argument. When used in this mode, {\tt recv\_object} will return {\tt None} when no data is available.

\subsection{Other Languages}

Many other languages are supported by ZeroMQ, and at least Ruby has supported ROOT bindings. Implementations will be similar to those given in C++ and Python. For examples of ZeroMQ in your language, see \href{https://github.com/imatix/zguide/tree/master/examples}{https://github.com/imatix/zguide/tree/master/examples}.

A client must `subscribe' to a ZeroMQ TCP `publish' socket and deserialize ROOT {\tt TObjects} using a {\tt TBufferFile}. The former is achieved with the ZeroMQ API: set up a context and a subscriber socket, and connect that socket to one or more server addresses. The latter is simple in principle -- create a {\tt TBufferFile}, set the buffer to the packet contents, and read out the appropriate class. This may be complicated (as it is in Python) by the language's hadling of string termination; care must be taken to ensure that the buffer is not treated as a string and truncated at the first null byte. For guidance, see the C++ and Python client library source code in {\tt lib}.


CouchDB bindings also exist for many languages, but none are essential since Couch communicates using JSON strings sent over HTTP. To interact with a database, code needs to make HTTP queries and convert JSON strings into native objects. All major languages have such facilities. If no library exists for your language, details on the CouchDB changes API are available at \href{http://wiki.apache.org/couchdb/HTTP\_database\_API\#Changes}{http://wiki.apache.org/couchdb/HTTP\_database \_API\#Changes}.

\clearpage
\section{Appendix: Packed Data Model}
This is a complete listing of all packed format classes, taken from RAT's PackedEvent.hh.

\subsection{class GenericRec : public TObject}
(empty)

\subsection{class PackedRec : public TObject}
\begin{itemize}
\item UInt\_t RecordType
\item GenericRec *Rec
\end{itemize}

\subsubsection{Record Types}
\begin{enumerate}
\setcounter{enumi}{-1}
\item Empty
\item Detector event
\item RHDR
\item CAAC
\item CAST
\item TRIG
\item EPED
\end{enumerate}

\subsection{class PackedEvent : public GenericRec}
\begin{itemize}
\item UInt\_t MTCInfo[kNheaders] (6 words for the event header from the MTC)
\item UInt\_t RunID
\item UInt\_t SubRunID
\item UInt\_t NHits
\item UInt\_t EVOrder
\item ULong64\_t RunMask
\item char PackVer
\item char MCFlag
\item char DataType
\item char ClockStat10 
\item std::vector$<$PMTBundle$>$ PMTBundles
\end{itemize}

\subsection{class PMTBundle}
\begin{itemize}
\item UInt\_t Word[3] 
\end{itemize}

\subsection{class EPED : public GenericRec}
\begin{itemize}
\item UInt\_t GTDelayCoarse
\item UInt\_t GTDelayFine
\item UInt\_t QPedAmp
\item UInt\_t QPedWidth
\item UInt\_t PatternID
\item UInt\_t CalType
\item UInt\_t EventID (GTID of first events in this bank validity)
\item UInt\_t RunID (doublecheck on the run)
\end{itemize}

\subsection{class TRIG : public GenericRec}
\begin{itemize}
\item UInt\_t TrigMask
\item UShort\_t Threshold[10]
\item UShort\_t TrigZeroOffset[10]
\item UInt\_t PulserRate
\item UInt\_t MTC\_CSR
\item UInt\_t LockoutWidth
\item UInt\_t PrescaleFreq
\item UInt\_t EventID (GTID of first events in this banks validity)
\item UInt\_t RunID (doublecheck on the run)
\end{itemize}

\subsubsection{Array Indices}
Arrays correspond to:
\begin{enumerate}
\setcounter{enumi}{-1}
\item N100Lo
\item N100Med
\item N100Hi
\item N20
\item N20LB
\item ESUMLo
\item ESUMHi
\item OWLn
\item OWLELo
\item OWLEHi
\end{enumerate}

\subsection{class RHDR : public GenericRec}
\begin{itemize}
\item UInt\_t Date
\item UInt\_t Time
\item char DAQVer
\item UInt\_t CalibTrialID
\item UInt\_t SrcMask
\item UInt\_t RunMask
\item UInt\_t CrateMask
\item UInt\_t FirstEventID
\item UInt\_t ValidEventID
\item UInt\_t RunID (doublecheck on the run)
\end{itemize}

\subsection{class CAST : public GenericRec}
\begin{itemize}
\item UShort\_t SourceID
\item UShort\_t SourceStat
\item UShort\_t NRopes
\item float ManipPos[3]
\item float ManipDest[3]
\item float SrcPosUncert1
\item float SrcPosUncert2[3]
\item float LBallOrient
\item std::vector$<$int$>$ RopeID
\item std::vector$<$float$>$ RopeLen
\item std::vector$<$float$>$ RopeTargLen
\item std::vector$<$float$>$ RopeVel
\item std::vector$<$float$>$ RopeTens
\item std::vector$<$float$>$ RopeErr
\end{itemize}

\subsection{class CAAC : public GenericRec}
\begin{itemize}
\item float AVPos[3]
\item float AVRoll[3] (roll, pitch and yaw)
\item float AVRopeLength[7]
\end{itemize}

\end{document}

