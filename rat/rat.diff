Index: src/cmd/ProcBlockManager.cc
===================================================================
--- src/cmd/ProcBlockManager.cc	(revision 650)
+++ src/cmd/ProcBlockManager.cc	(working copy)
@@ -36,6 +36,7 @@
 #include <RAT/GenLikePosPDFProc.hh>
 #include <RAT/GenLikeEnergyPDFProc.hh>
 #include <RAT/PackEvents.hh>
+#include <RAT/DispatchEvents.hh>
 #include <RAT/PMTCalib.hh>
 #include <RAT/SanityCheckProc.hh>
 #include <RAT/RingOfFire.hh>
@@ -90,9 +91,8 @@
   // I/O
   fProcAllocators["outroot"] = new ProcAllocatorTmpl<OutROOTProc>;
   fProcAllocators["outnet"] = new ProcAllocatorTmpl<OutNetProc>;
-  // Event packing
   fProcAllocators["pack"] = new ProcAllocatorTmpl<PackEvents>;
-  // Filling RCH File 
+  fProcAllocators["dispatch"] = new ProcAllocatorTmpl<DispatchEvents>;
   fProcAllocators["fillRCH"] = new ProcAllocatorTmpl<FillRCHProc>;
 
   // Fitters
Index: src/io/PackEvents.hh
===================================================================
--- src/io/PackEvents.hh	(revision 650)
+++ src/io/PackEvents.hh	(working copy)
@@ -1,9 +1,9 @@
 ////////////////////////////////////////////////////////////////////
 // Last svn revision: $Id$
 ////////////////////////////////////////////////////////////////////
-/// \class RAT:PackEvents
+/// \class RAT::PackEvents
 ///
-/// \brief  Packer, to pack MC events into the packed root format
+/// \brief Packer, to pack MC events into the packed root format
 ///          
 /// \author Gabriel D. Orebi Gann <orebi@hep.upenn.edu>
 ///
@@ -11,13 +11,14 @@
 ///     09 Apr 2010 : Gabriel Orebi Gann - extend packing to include
 ///                   header info, as well as detector events
 ///     28 May 2010 : Gabriel Orebi Gann - flip final bit of PMT Q,T
-///                   values (to mimic the ADC in data, which 
-///                   outputs them flipped)
+///                   values (to mimic the ADC in data, which outputs them 
+///                   flipped)
 ///     03 Mar 2011 : Gabriel Orebi Gann - edits to incorporate new channel 
 ///                   types
 ///     17 Oct 2011 : Gabriel Orebi Gann - Move bit funcs to BitManip
+///     11 Nov 2011 : A Mastbaum - refactor so that packing functions can be
+///                   reused in other code
 ///
-///
 ///  \detail  This class packs the full simulated MC events into
 ///           the same packed root format that the event builder
 ///           outputs.  i.e. the result is a file that looks as 
@@ -26,17 +27,12 @@
 ///           NB since we are mimicking real data, only the EV side
 ///           of the events is packed, not the MC side.
 ///
-///
-///
-///
 ////////////////////////////////////////////////////////////////////
-#ifndef __RATPackEvents___
-#define __RATPackEvents___
+#ifndef __RAT_PackEvents___
+#define __RAT_PackEvents___
 
 #include <RAT/Processor.hh>
-#include <RAT/DS/Run.hh>
 #include <RAT/DS/PackedEvent.hh>
-#include <RAT/BitManip.hh>
 
 class TFile;
 class TTree;
@@ -45,54 +41,26 @@
 
 class PackEvents : public Processor {
 public:
-//  static Int_t fRunNum;
   PackEvents();
   virtual ~PackEvents();
+  virtual Processor::Result DSEvent(DS::Root* ds);
 
   // file - string, name of file to open for output, file will be erased
-  // updatefile - string, name of file to append to
-  // (do not use both file and update file)
   virtual void SetS(std::string param, std::string value);
   
   // autosave - integer, update root file every N kilobytes
   virtual void SetI(std::string param, int value);
 
-  virtual Processor::Result DSEvent(DS::Root *ds);
-
-  virtual bool OpenFile(std::string theFilename);
-  virtual std::string GetFilename() { return fFileName; };
-
 protected:
-  DS::PMTBundle PackPMT(DS::PMTUnCal *pmt, unsigned int gtid);
-  DS::PackedEvent* PackHeader(DS::EV *ev);
-  DS::PackedEvent* PackEvent(DS::EV *ev);
-  void MakeRunHeader(DS::Root *ds);
-  void MakeAVHeader(DS::Run *run);
-  void MakeManipHeader(DS::Run *run);
-  void MakeEventHeader(DS::Root *ds);
-  void MakeEPEDHeader(DS::EPEDInfo *eped);
-  void MakeTRIGHeader(DS::TRIGInfo *trig);
-  void Die(std::string message, int flag_err, int info1, int info2, int return_code=1);
-  
-  char fPackVer;
-  int fRunID;
   int fEVID;
-  int fSubRunID;
-  ULong64_t fRunType;
-  char fMCFlag;
-  char fDataType;
+  int fAutosave;
 
-  std::string fDefaultFileName;
-  std::string fFileName;
-  TFile *fFile;
-  TTree *fTree;
-  DS::PackedEvent *branchPackedEv;
-  DS::PackedRec *branchPackedRec;
-  //DS::PackedEvent fPackedEV;
-  Int_t fAutosave;
-  BitManip *fBits;
+  TFile* fFile;
+  TTree* fTree;
+  DS::PackedRec* fBranchRec;
 };
 
 } // namespace RAT
 
 #endif
+
Index: src/io/Pack.cc
===================================================================
--- src/io/Pack.cc	(revision 0)
+++ src/io/Pack.cc	(revision 0)
@@ -0,0 +1,543 @@
+#include <RAT/Pack.hh>
+#include <RAT/Log.hh>
+#include <RAT/BitManip.hh>
+#include <RAT/DS/Root.hh>
+#include <RAT/DS/PackedEvent.hh>
+#include <RAT/DS/RunStore.hh>
+#include <RAT/DS/Run.hh>
+#include <RAT/DS/HeaderInfo.hh>
+#include <RAT/DetectorConstruction.hh>
+
+namespace RAT {
+
+namespace Pack {
+
+// packing functions
+DS::PackedRec* MakeTRIGHeader(DS::Root* ds)
+{
+  DS::TRIGInfo* trig = ds->GetHeaderInfo()->GetTRIGInfo();
+  DS::TRIG* rec = new DS::TRIG();
+
+  rec->TrigMask = trig->GetTrigMask();
+  rec->PulserRate = trig->GetPulserRate();
+  rec->MTC_CSR = trig->GetMTC_CSR();
+  rec->LockoutWidth = trig->GetLockoutWidth();
+  rec->PrescaleFreq = trig->GetPrescaleFreq();
+  rec->EventID = trig->GetEventID();
+  rec->RunID = trig->GetRunID();
+  
+  int ntrigthold = trig->GetNTrigTHold();
+  int ntrigzero = trig->GetNTrigZeroOffset();
+
+  for(int i=0; i<10; i++) {
+    rec->Threshold[i] = 0;
+    rec->TrigZeroOffset[i] = 0;
+    if (i < ntrigthold)
+      rec->Threshold[i] = trig->GetTrigTHold(i);
+    if (i < ntrigzero)
+      rec->TrigZeroOffset[i] = trig->GetTrigZeroOffset(i);
+  }
+
+  DS::PackedRec* PackedRec = new DS::PackedRec();
+  PackedRec->RecordType = 5;
+  PackedRec->Rec = rec;
+
+  return PackedRec;
+}
+
+DS::PackedRec* MakeEPEDHeader(DS::Root* ds)
+{
+  DS::EPEDInfo* eped = ds->GetHeaderInfo()->GetEPEDInfo();
+  DS::EPED* rec = new DS::EPED();
+
+  rec->GTDelayCoarse = eped->GetGTDelayCoarse();
+  rec->GTDelayFine = eped->GetGTDelayFine();
+  rec->QPedAmp = eped->GetQPedAmp();
+  rec->QPedWidth = eped->GetQPedWidth();
+  rec->PatternID = eped->GetPatternID();
+  rec->CalType = eped->GetCalType();
+  rec->EventID = eped->GetEventID();
+  rec->RunID = eped->GetRunID();
+
+  DS::PackedRec* PackedRec = new DS::PackedRec();
+  PackedRec->RecordType = 6;
+  PackedRec->Rec = rec;
+  
+  return PackedRec;
+}
+
+DS::PackedRec* MakeRunHeader(DS::Root* ds)
+{
+  DS::Run* run = RAT::DS::RunStore::GetRun(ds);
+  DS::RHDR* rec = new DS::RHDR();
+
+  rec->Date = run->GetDate();
+  rec->Time = run->GetTime();
+  rec->DAQVer = run->GetDAQVer();
+  rec->CalibTrialID = run->GetCalibTrialID();
+  rec->SrcMask = run->GetSrcMask();
+  rec->RunMask = run->GetRunType();
+  rec->CrateMask = run->GetCrateMask();
+  rec->FirstEventID = run->GetFirstEventID();
+  rec->ValidEventID = run->GetValidEventID();
+  rec->RunID = run->GetRunID();
+
+  DS::PackedRec* PackedRec = new DS::PackedRec();
+  PackedRec->RecordType = 2;
+  PackedRec->Rec = rec;
+
+  return PackedRec;
+}
+
+DS::PackedRec* MakeAVHeader(DS::Root* ds)
+{
+  DS::AVStat* avstat = RAT::DS::RunStore::GetRun(ds)->GetAVStat();
+  DS::CAAC* rec = new DS::CAAC();
+
+  for (int i=0; i<3; i++) {
+    rec->AVPos[i] = avstat->GetPosition(i);
+    rec->AVRoll[i] = avstat->GetRoll(i);
+  }
+
+  for (int i=0; i<7; i++) {
+    rec->AVRopeLength[i] = avstat->GetRopeLength(i);
+  }
+
+  DS::PackedRec* PackedRec = new DS::PackedRec();
+  PackedRec->RecordType = 3;
+  PackedRec->Rec = rec;
+
+  return PackedRec;
+}
+
+DS::PackedRec* MakeManipHeader(DS::Root* ds)
+{
+  DS::ManipStat* manipstat = RAT::DS::RunStore::GetRun(ds)->GetManipStat();
+  DS::CAST* rec = new DS::CAST();
+
+  for (int i=0; i<3; i++) {
+    rec->ManipPos[i] = manipstat->GetManipPos(i);
+    rec->ManipDest[i] = manipstat->GetManipDest(i);
+    rec->SrcPosUncert2[i] = manipstat->GetSrcPosUnc(i);
+  }
+
+  for (int i=0; i<manipstat->GetNRopes(); i++) {
+    rec->RopeID.push_back(manipstat->GetRopeID(i));
+    rec->RopeLen.push_back(manipstat->GetRopeLength(i));
+    rec->RopeTargLen.push_back(manipstat->GetRopeTargLength(i));
+    rec->RopeVel.push_back(manipstat->GetRopeVelocity(i));
+    rec->RopeTens.push_back(manipstat->GetRopeTension(i));
+    rec->RopeErr.push_back(manipstat->GetRopeErr(i));
+  }
+
+  rec->SourceID = manipstat->GetSrcID();
+  rec->SourceStat = manipstat->GetSrcStatus();
+  rec->NRopes = manipstat->GetNRopes();
+  rec->SrcPosUncert1 = manipstat->GetSrcPosUnc();
+  rec->LBallOrient = manipstat->GetLaserballOrient();
+
+  DS::PackedRec* PackedRec = new DS::PackedRec();
+  PackedRec->RecordType = 4;
+  PackedRec->Rec = rec;
+
+  return PackedRec;
+}
+
+DS::PackedRec* PackEvent(DS::Root* ds, int iev)
+{
+  DS::EV* ev = ds->GetEV(iev);
+  DS::PackedEvent* PackedEV = new DS::PackedEvent();
+
+  // get event level info
+  unsigned trigError = ev->GetTrigError();
+  unsigned trigType = ev->GetTrigType();
+  unsigned eventID = ev->GetEventID();
+  unsigned long clockCount50 = ev->GetClockCount50();
+  unsigned long clockCount10 = ev->GetClockCount10();
+  char clockStat10 = ev->GetClockStat10();
+  int nhits = ev->GetNhits();
+  int npmtall = ev->GetPMTAllUnCalCount();
+
+  // initialize header words
+  std::vector<int> header(6, 0);
+
+  // check some lengths
+  Log::Assert(BitManip::CheckLength(nhits, 16), "Pack: nhit has wrong length");
+  Log::Assert(BitManip::CheckLength(clockStat10, 4), "Pack: clockStat10 has wrong length");
+  Log::Assert(BitManip::CheckLength(eventID, 24), "Pack: GTID has wrong length");
+  Log::Assert(BitManip::CheckLength(trigError, 15), "Pack: TrigError has wrong length");
+
+  // pack header words
+  unsigned clock50part1 = (int) BitManip::GetBits((ULong64_t) clockCount50, 0, 11);
+  unsigned clock50part2 = (int) BitManip::GetBits((ULong64_t) clockCount50, 11, 32);
+  unsigned clock10part1 = (int) BitManip::GetBits((ULong64_t) clockCount10, 0, 32);
+  unsigned clock10part2 = (int) BitManip::GetBits((ULong64_t) clockCount10, 32, 21);
+
+  Log::Assert(BitManip::CheckLength(clock50part1, 11), "Pack: clock50part1 has wrong length");
+  Log::Assert(BitManip::CheckLength(clock50part2, 32), "Pack: clock50part2 has wrong length");
+  Log::Assert(BitManip::CheckLength(clock10part1, 32), "Pack: clock10part1 has wrong length");
+  Log::Assert(BitManip::CheckLength(clock10part2, 21), "Pack: clock10part2 has wrong length");
+ 
+  unsigned long p1 = clock10part1;
+  unsigned long p2 = clock10part2;
+  unsigned long test10 = (p2<<32) + p1;
+  if (test10 != clockCount10)
+    warn << dformat("Pack: test10 (%lu) != clockCount10 (%lu)\n", test10, clockCount10);
+  
+  header[0] = clock10part1;                                   // 32 bits of 10MHz clock
+  header[1] = clock10part2;                                   // 21 bits of ""
+  header[1] = BitManip::SetBits(header[1], 21, clock50part1); // 11 bits of 50MHz clock 
+  header[2] = clock50part2;                                   // 32 bits of ""
+
+  unsigned int trig1 = BitManip::GetBits(trigType, 0, 8);
+  unsigned int trig2 = BitManip::GetBits(trigType, 8, 19);
+  Log::Assert(BitManip::CheckLength(trigType, 27), "Pack: TrigWord has wrong length");
+  Log::Assert(BitManip::CheckLength(trig1, 8), "Pack: TrigWordP1 has wrong length");
+  Log::Assert(BitManip::CheckLength(trig2, 19), "Pack: TrigWordP2 has wrong length");
+  
+  header[3] = eventID;                                        // 24 bits of GTID
+  header[3] = BitManip::SetBits(header[3], 24, trig1);        // 8 bits of Trigger word
+  header[4] = trig2;                                          // 19 bits of Trigger word
+  header[5] = BitManip::SetBits(header[5], 17, trigError);    // 15 bits of TrigError word
+  
+  for (int i=0; i<6; i++)
+    PackedEV->MTCInfo[i] = header[i];
+
+  PackedEV->PackVer = packVer;
+  PackedEV->EVOrder = eventID; //FIXME
+  PackedEV->NHits = nhits;
+  PackedEV->ClockStat10 = clockStat10;
+
+  DS::Run* run = RAT::DS::RunStore::GetRun(ds);
+  PackedEV->DataType = run->GetDataType();
+  PackedEV->MCFlag = run->GetMCFlag();
+  PackedEV->RunMask = run->GetRunType();
+  PackedEV->RunID = run->GetRunID();
+  PackedEV->SubRunID = run->GetSubRunID();
+
+  // set number of pmt bundles
+  PackedEV->PMTBundles.resize(npmtall);
+  
+  // pack pmt bundles
+  for (int inh=0; inh<npmtall; inh++) {
+    DS::PMTUnCal* pmt = ev->GetPMTAllUnCal(inh);
+    PackedEV->PMTBundles[inh] = MakePMTBundle(pmt, eventID);
+  }
+
+  DS::PackedRec* PackedRec = new DS::PackedRec();
+  PackedRec->RecordType = 1;
+  PackedRec->Rec = PackedEV;
+
+  return PackedRec;
+}
+
+// pack PMTBundles
+DS::PMTBundle MakePMTBundle(DS::PMTUnCal* pmt, unsigned gtid)
+{
+  DS::PMTBundle bundle;
+
+  // get pmt level info
+  int lcn = pmt->GetID();
+  int icrate = BitManip::GetCrate(lcn);
+  int icard = BitManip::GetCard(lcn);
+  int ichan = BitManip::GetChannel(lcn);
+  int cell = pmt->GetCellID();
+
+  // order of flags in chanFlags, from least sig bit upwards:
+  // CGT ES16, CGT ES24, Missed Count, NC/CC Flag, LGISELECT, CMOS ES16
+  char chanFlags = pmt->GetChanFlags();
+
+  // get uncalibrated charges and time
+  unsigned short qhs = pmt->GetsQHS();
+  unsigned short qhl = pmt->GetsQHL();
+  unsigned short qlx = pmt->GetsQLX();
+  unsigned short tac = pmt->GetsPMTt();
+  
+  // flip last bit of Q,T to mimic the ADCs
+  qhs = BitManip::FlipBit(qhs,11);
+  qhl = BitManip::FlipBit(qhl,11);
+  qlx = BitManip::FlipBit(qlx,11);
+  tac = BitManip::FlipBit(tac,11);
+
+  // check some lengths
+  Log::Assert(BitManip::CheckLength(qlx, 12), "Pack: QLX has wrong length");
+  Log::Assert(BitManip::CheckLength(qhs,12), "Pack: QHS has wrong length");
+  Log::Assert(BitManip::CheckLength(qhl,12), "Pack: QH has wrong lengthL");
+  Log::Assert(BitManip::CheckLength(tac,12), "Pack: TAC has wrong length");
+  Log::Assert(BitManip::CheckLength(cell,4), "Pack: CellID has wrong length");
+  Log::Assert(BitManip::CheckLength(icrate,5), "Pack: Crate# has wrong length");
+  Log::Assert(BitManip::CheckLength(icard,4), "Pack: Card# has wrong length");
+  Log::Assert(BitManip::CheckLength(ichan,5), "Pack: Channel# has wrong length");
+  
+  // pack this bundle
+  // first word
+  int word1 = BitManip::GetBits(gtid, 0, 16);      // 16 bits of GTID
+  word1 = BitManip::SetBits(word1, 16, ichan);     // 5 bits of ichan
+  word1 = BitManip::SetBits(word1, 21, icrate);    // 5 bits of icrate
+  word1 = BitManip::SetBits(word1, 26, icard);     // 4 bits of icard
+  if (BitManip::TestBit(chanFlags,0))              // 1 bit for CGT ES16
+    word1 = BitManip::SetBit(word1, 30);
+  if (BitManip::TestBit(chanFlags,1))              // 1 bit for CGT ES24
+    word1 = BitManip::SetBit(word1, 31);
+  
+  // second word
+  int word2 = qlx;                                 // 12 bits for QLX
+  word2 = BitManip::SetBits(word2, 12, cell);      // 4 bits for cellID
+  word2 = BitManip::SetBits(word2, 16, qhs);       // 12 bits for QHS
+  if (BitManip::TestBit(chanFlags,2))              // 1 bit for `Missed count'
+    word2 = BitManip::SetBit(word2, 28);
+  if (BitManip::TestBit(chanFlags,3))              // 1 bit for NC/CC
+    word2 = BitManip::SetBit(word2, 29);
+  if (BitManip::TestBit(chanFlags,4))              // 1 bit for LGISelect
+    word2 = BitManip::SetBit(word2, 30);
+  if (BitManip::TestBit(chanFlags,5))              // 1 bit for CMOS ES16
+    word2 = BitManip::SetBit(word2, 31);
+  
+  // third word
+  int word3 = qhl;                                 // 12 bits for QHL
+  int gtidpart1 = BitManip::GetBits(gtid, 16, 4);
+  int gtidpart2 = BitManip::GetBits(gtid, 20, 4);
+  word3 = BitManip::SetBits(word3, 12, gtidpart1); // 4 bits of GTID
+  word3 = BitManip::SetBits(word3, 16, tac);       // 12 bits for TAC
+  word3 = BitManip::SetBits(word3, 28, gtidpart2); // 4 bits of GTID
+
+  bundle.Word[0] = word1;
+  bundle.Word[1] = word2;
+  bundle.Word[2] = word3;
+
+  return bundle;
+}
+
+// unpacking functions
+DS::Root* UnpackEvent(DS::PackedEvent* pev, DS::TRIGInfo* trig=NULL, DS::EPEDInfo* eped=NULL)
+{
+  DS::Root* ds = new DS::Root();
+  DS::EV* ev = ds->AddNewEV();
+
+  // copy header info, if provided
+  DS::HeaderInfo* header = ds->GetHeaderInfo();
+
+  if (trig) {
+    DS::TRIGInfo* triginfo = header->GetTRIGInfo();
+    *triginfo = *trig;
+  }
+
+  if (eped) {
+    DS::EPEDInfo* epedinfo = header->GetEPEDInfo();
+    *epedinfo = *eped;
+  }
+
+  // set root/ds level info
+  ds->SetRunID(pev->RunID);
+  ds->SetSubRunID(pev->SubRunID);
+
+  // unpack header information: 6 MTCInfo words + clockstat10
+  unsigned long clock10part1 = pev->MTCInfo[0];
+  unsigned long clock10part2 = BitManip::GetBits(pev->MTCInfo[1],0,21);
+  unsigned long clockCount10 = (clock10part2 << 32) + clock10part1;
+
+  unsigned long clock50part1 = BitManip::GetBits(pev->MTCInfo[1],21,11);
+  unsigned long clock50part2 = pev->MTCInfo[2];
+  unsigned long clockCount50 = (clock50part2 << 11) + clock50part1;
+
+  unsigned eventID = BitManip::GetBits(pev->MTCInfo[3],0,24);
+  
+  unsigned trigpart1 = BitManip::GetBits(pev->MTCInfo[3],24,8);
+  unsigned trigpart2 = BitManip::GetBits(pev->MTCInfo[4],0,19);
+  unsigned trigType = (trigpart2 << 8) + trigpart1;
+  
+  unsigned trigError = BitManip::GetBits(pev->MTCInfo[5],17,15);
+
+  ev->SetClockStat10(pev->ClockStat10);
+  ev->SetTrigError(trigError);
+  ev->SetTrigType(trigType);
+  ev->SetEventID(eventID);
+  ev->SetClockCount50(clockCount50);
+  ev->SetClockCount10(clockCount10);
+    
+  // set UT from 10MHz clock counts
+  unsigned long Period = 100; // 10MHz period in ns
+  unsigned long Total = clockCount10 * Period;
+  unsigned long NNsec = Total % (unsigned long)1e9;
+  unsigned long NSecs = Total / 1e9;
+  unsigned long NDays = NSecs / 86400;
+  NSecs = NSecs - (86400 * NDays);
+  
+  unsigned ndays = (unsigned) NDays;
+  unsigned nsecs = (unsigned) NSecs;
+  unsigned nns = (unsigned) NNsec;
+  
+  ev->SetUTDays(ndays);
+  ev->SetUTSecs(nsecs);
+  ev->SetUTNSecs(nns);
+
+  // unpack hit information from pmt bundles
+  for (size_t inh=0; inh<pev->PMTBundles.size(); inh++){
+    DS::PMTBundle bundle = pev->PMTBundles[inh];
+
+    // figure out pmt type from dqxx
+    unsigned ichan = BitManip::GetBits(bundle.Word[0], 16, 5);
+    unsigned icard = BitManip::GetBits(bundle.Word[0], 26, 4);
+    unsigned icrate = BitManip::GetBits(bundle.Word[0], 21, 5);
+    unsigned lcn = BitManip::GetLCN(icrate, icard, ichan);
+    int type = DetectorConstruction::fTubeStatus[lcn];
+
+    DS::PMTUnCal* pmt = ev->AddNewPMTUnCal(type);
+    DS::PMTUnCal* pmtUnpacked = UnpackPMT(&bundle);
+    *pmt = *pmtUnpacked;
+    delete pmtUnpacked;
+  }
+
+  return ds;
+}
+
+DS::Run* UnpackRHDR(DS::RHDR* rhdr)
+{
+  DS::Run* run = new DS::Run();
+
+  run->SetDate(rhdr->Date);
+  run->SetTime(rhdr->Time);
+  run->SetDAQVer(rhdr->DAQVer);
+  run->SetCalibTrialID(rhdr->CalibTrialID);
+  run->SetSrcMask(rhdr->SrcMask);
+  run->SetRunType(rhdr->RunMask);
+  run->SetCrateMask(rhdr->CrateMask);
+  run->SetFirstEventID(rhdr->FirstEventID);
+  run->SetValidEventID(rhdr->ValidEventID);
+  run->SetRunID(rhdr->RunID);
+
+  return run;
+}
+
+DS::AVStat* UnpackCAAC(DS::CAAC* caac)
+{
+  DS::AVStat* avstat = new DS::AVStat();
+
+  for (int i=0; i<3; i++) {
+    avstat->SetPosition(i, caac->AVPos[i]);
+    avstat->SetRoll(i, caac->AVRoll[i]);
+  }
+
+  for (int i=0; i<7; i++)
+    avstat->SetRopeLength(i, caac->AVRopeLength[i]);
+
+  return avstat;
+}
+
+DS::ManipStat* UnpackCAST(DS::CAST* cast)
+{
+  DS::ManipStat* manipstat = new DS::ManipStat();
+
+  for (int i=0; i<3; i++) {
+    manipstat->SetManipPos(i, cast->ManipPos[i]);
+    manipstat->SetManipDest(i, cast->ManipDest[i]);
+    manipstat->SetSrcPosUnc(i, cast->SrcPosUncert2[i]);
+  }
+
+  manipstat->SetSrcID(cast->SourceID);
+  manipstat->SetSrcStatus(cast->SourceStat);
+  manipstat->SetNRopes(cast->NRopes);
+  manipstat->SetSrcPosUnc(cast->SrcPosUncert1);
+  manipstat->SetLaserballOrient(cast->LBallOrient);
+
+  for (int i=0; i<manipstat->GetNRopes(); i++) {
+    manipstat->SetRopeID(i, cast->RopeID[i]);
+    manipstat->SetRopeLength(i, cast->RopeLen[i]);
+    manipstat->SetRopeTargLength(i, cast->RopeTargLen[i]);
+    manipstat->SetRopeVelocity(i, cast->RopeVel[i]);
+    manipstat->SetRopeTension(i, cast->RopeTens[i]);
+    manipstat->SetRopeErr(i, cast->RopeErr[i]);
+  }
+
+  return manipstat;
+}
+
+DS::TRIGInfo* UnpackTRIG(DS::TRIG* trig)
+{
+  DS::TRIGInfo* triginfo = new DS::TRIGInfo();
+
+  triginfo->SetTrigMask(trig->TrigMask);
+  triginfo->SetPulserRate(trig->PulserRate);
+  triginfo->SetMTC_CSR(trig->MTC_CSR);
+  triginfo->SetLockoutWidth(trig->LockoutWidth);
+  triginfo->SetPrescaleFreq(trig->PrescaleFreq);
+  triginfo->SetEventID(trig->EventID);
+  triginfo->SetRunID(trig->RunID); 
+  triginfo->SetNTrigTHold(10);
+  triginfo->SetNTrigZeroOffset(10);
+
+  for (int i=0; i<10; i++) {
+    triginfo->SetTrigTHold(i, trig->Threshold[i]);
+    triginfo->SetTrigZeroOffset(i, trig->TrigZeroOffset[i]);
+  }
+
+  return triginfo;
+}
+
+DS::EPEDInfo* UnpackEPED(DS::EPED* eped)
+{
+  DS::EPEDInfo* epedinfo = new DS::EPEDInfo();
+
+  epedinfo->SetGTDelayCoarse(eped->GTDelayCoarse);
+  epedinfo->SetGTDelayFine(eped->GTDelayFine);
+  epedinfo->SetQPedAmp(eped->QPedAmp);
+  epedinfo->SetQPedWidth(eped->QPedWidth);
+  epedinfo->SetPatternID(eped->PatternID);
+  epedinfo->SetCalType(eped->CalType);
+  epedinfo->SetEventID(eped->EventID);
+  epedinfo->SetRunID(eped->RunID);
+
+  return epedinfo;
+}
+
+DS::PMTUnCal* UnpackPMT(DS::PMTBundle* bundle)
+{
+  DS::PMTUnCal* pmt = new DS::PMTUnCal();
+
+  unsigned ichan = BitManip::GetBits(bundle->Word[0], 16, 5);
+  unsigned icard = BitManip::GetBits(bundle->Word[0], 26, 4);
+  unsigned icrate = BitManip::GetBits(bundle->Word[0], 21, 5);
+  unsigned lcn = BitManip::GetLCN(icrate, icard, ichan);
+  unsigned cell = BitManip::GetBits(bundle->Word[1], 12, 4);
+
+  // 3 pmt words
+  char chanflags = 0;
+  if (BitManip::TestBit(bundle->Word[0], 30))
+    chanflags = BitManip::SetBit(chanflags, 0);
+  if (BitManip::TestBit(bundle->Word[0], 31))
+    chanflags = BitManip::SetBit(chanflags, 1);
+  if (BitManip::TestBit(bundle->Word[1], 28))
+    chanflags = BitManip::SetBit(chanflags, 2);
+  if (BitManip::TestBit(bundle->Word[1], 29))
+    chanflags = BitManip::SetBit(chanflags, 3);
+  if (BitManip::TestBit(bundle->Word[1], 30))
+    chanflags = BitManip::SetBit(chanflags, 4);
+  if (BitManip::TestBit(bundle->Word[1], 31))
+    chanflags = BitManip::SetBit(chanflags, 5);
+  
+  unsigned short qhs = BitManip::GetBits(bundle->Word[1], 16, 12);
+  unsigned short qhl = BitManip::GetBits(bundle->Word[2], 0, 12);
+  unsigned short qlx = BitManip::GetBits(bundle->Word[1], 0, 12);
+  unsigned short tac = BitManip::GetBits(bundle->Word[2], 16, 12);
+  
+  // flip last bit of Q, T (adc weirdness)
+  qhs = BitManip::FlipBit(qhs,11);
+  qhl = BitManip::FlipBit(qhl,11);
+  qlx = BitManip::FlipBit(qlx,11);
+  tac = BitManip::FlipBit(tac,11);
+  
+  pmt->SetID(lcn);
+  pmt->SetCellID(cell);
+  pmt->SetChanFlags(chanflags);
+  pmt->SetsQHS(qhs);
+  pmt->SetsQHL(qhl);
+  pmt->SetsQLX(qlx);
+  pmt->SetsPMTt(tac);
+
+  return pmt;
+}
+
+} // namespace Pack
+
+} // namespace RAT
+
Index: src/io/UnPackEvents.hh
===================================================================
--- src/io/UnPackEvents.hh	(revision 650)
+++ src/io/UnPackEvents.hh	(working copy)
@@ -1,104 +0,0 @@
-////////////////////////////////////////////////////////////////////
-// Last svn revision: $Id$
-////////////////////////////////////////////////////////////////////
-/// \class RAT:UnPackEvents
-///
-/// \brief  Unpacker, to unpack the packed data format into the RAT DS
-///          
-/// \author Gabriel D. Orebi Gann <orebi@hep.upenn.edu>
-///
-/// REVISION HISTORY:\n
-///     09 Apr 2010 : Gabriel Orebi Gann - extend routines to
-///                   unpack header info, as well as detector events,
-///                   and various consistency checks (e.g. record 
-///                   ordering, PMTBundle eventID matches event-level
-///                   eventID etc)
-///     28 May 2010 : Gabriel Orebi Gann - flip final bit of PMT Q,T
-///                   values (the ADC outputs them flipped)
-///     03 Mar 2011 : Gabriel Orebi Gann - edits to incorporate new channel 
-///                   types
-///     17 Oct 2011 : Gabriel Orebi Gann - Move bit funcs to BitManip
-///
-///
-///  \detail  This class unpacks files from the packed data format
-///           that is output by the event builder, and populates the
-///           full RAT DS.  This can be run on either real data, or
-///           on packed MC files.
-///
-///
-///
-///
-////////////////////////////////////////////////////////////////////
-
-#ifndef __RAT_UnPackEvents__
-#define __RAT_UnPackEvents__
-
-#include <string>
-#include <RAT/Producer.hh>
-#include <globals.hh>
-#include <RAT/DS/EV.hh>
-#include <RAT/DS/PMTUnCal.hh>
-#include <RAT/DS/PackedEvent.hh>
-#include <RAT/DS/Root.hh>
-#include <RAT/DS/Run.hh>
-#include <RAT/BitManip.hh>
-
-class G4UIcmdWithAString;
-
-namespace RAT {
-
-const int kNheaders = 6;
-const int kNpmt = 3;
-
-class UnPackEvents : public Producer {
-public:
-  UnPackEvents();
-  UnPackEvents(ProcBlock *block);
-  virtual ~UnPackEvents();
-
-  virtual bool ReadEvents(G4String filename);
-
-  // override G4UImessenger (from Producer) methods
-  virtual G4String GetCurrentValue(G4UIcommand * command);
-  virtual void SetNewValue(G4UIcommand * command,G4String newValue);
-
-
-protected:
-  void Init();
-  void UnpackHeader(DS::EV *ev);
-  void UnpackPMT(DS::PMTUnCal *pmt, int lcn);
-  std::string IdentifyRecord(int input);
-  void UnPackRHDR(DS::RHDR *branchRHDR, DS::Run* &run);
-  void UnPackCAAC(DS::CAAC *branchCAAC, DS::Run* &run);
-  void UnPackCAST(DS::CAST *branchCAST, DS::Run* &run);
-  void UnPackTRIG(DS::TRIG *branchTRIG, DS::Root* &ds);
-  void UnPackEPED(DS::EPED *branchEPED, DS::Root* &ds);
-  bool CheckOrder(std::string id, int prev, int next, int header);
-  
-  void Die(std::string message, int flag_err, int info1, int info2, int info3=0, int return_code=1);
-
-  std::string fFileName;
-  G4UIcmdWithAString *fReadCmd;
-  UInt_t fMTCInfo[kNheaders];
-  UInt_t fWord[kNpmt];
-  Int_t fNHits;
-  UInt_t fEVOrder;
-  char fClockStat10;
-  
-  Int_t fEventID;
-  Int_t fEvRHDR;
-  Int_t fEvTRIG;
-  Int_t fEvEPED;
-  bool fCheckRHDR;
-  bool fCheckTRIG;
-  bool fCheckEPED;
-  UInt_t fRunID;
-  ULong64_t fRunMask;
-  std::vector<int> fPMTtype;
-  BitManip *fBits;
-  
-};
-
-} // namespace RAT
-
-#endif
Index: src/io/avalanche.hpp
===================================================================
--- src/io/avalanche.hpp	(revision 0)
+++ src/io/avalanche.hpp	(revision 0)
@@ -0,0 +1,37 @@
+#include <string>
+#include <vector>
+#include <zmq.hpp>
+
+class TObject;
+class TClass;
+
+namespace avalanche {
+
+class server
+{
+    public:
+        server(std::string _addr);
+        ~server() {};
+        int sendObject(TObject* o);
+
+    protected:
+        std::string address;
+        zmq::context_t* context;
+        zmq::socket_t* socket;
+};
+
+class client {
+    public:
+        client(std::string _addr);
+        ~client();
+	void addServer(std::string _addr);
+	void* recvObject(TClass* cls, int flags=0);
+
+    protected:
+        std::vector<std::string> serv_addr;
+        zmq::context_t* context;
+        zmq::socket_t* socket;
+};
+
+} // namespace avalanche
+
Index: src/io/InPackedProducer.hh
===================================================================
--- src/io/InPackedProducer.hh	(revision 0)
+++ src/io/InPackedProducer.hh	(revision 0)
@@ -0,0 +1,55 @@
+////////////////////////////////////////////////////////////////////
+// Last svn revision: $Id: UnPackEvents.hh 628 2011-10-17 16:53:43Z orebi $
+////////////////////////////////////////////////////////////////////
+/// \class RAT::InPackedProducer
+///
+/// \brief  Unpacker, to unpack the packed data format into the RAT DS
+///          
+/// \author Gabriel D. Orebi Gann <orebi@hep.upenn.edu>
+///
+/// REVISION HISTORY:\n
+///     09 Apr 2010 : Gabriel Orebi Gann - extend routines to
+///                   unpack header info, as well as detector events,
+///                   and various consistency checks (e.g. record 
+///                   ordering, PMTBundle eventID matches event-level
+///                   eventID etc)
+///     28 May 2010 : Gabriel Orebi Gann - flip final bit of PMT Q,T
+///                   values (the ADC outputs them flipped)
+///     03 Mar 2011 : Gabriel Orebi Gann - edits to incorporate new channel 
+///                   types
+///     17 Oct 2011 : Gabriel Orebi Gann - Move bit funcs to BitManip
+///     19 Dec 2011 : A Mastbaum - factor unpacking functions out so that
+///                   they can be reused elsewhere (e.g. dispatcher reader)
+///
+///  \detail  This class unpacks files from the packed data format
+///           that is output by the event builder, and populates the
+///           full RAT DS.  This can be run on either real data, or
+///           on packed MC files.
+///
+////////////////////////////////////////////////////////////////////
+
+#ifndef __RAT_InPackedProducer__
+#define __RAT_InPackedProducer__
+
+#include <RAT/Producer.hh>
+#include <globals.hh>
+
+class G4UIcmdWithAString;
+
+namespace RAT {
+
+class InPackedProducer : public Producer {
+public:
+  InPackedProducer(ProcBlock* block);
+  virtual ~InPackedProducer() {};
+
+  virtual bool ReadEvents(G4String filename);
+  virtual void SetNewValue(G4UIcommand* command, G4String newValue);
+
+protected:
+  G4UIcmdWithAString* fReadCmd;
+};
+
+} // namespace RAT
+
+#endif
Index: src/io/DispatchEvents.hh
===================================================================
--- src/io/DispatchEvents.hh	(revision 0)
+++ src/io/DispatchEvents.hh	(revision 0)
@@ -0,0 +1,41 @@
+////////////////////////////////////////////////////////////////////
+/// \class RAT::DispatchEvents
+///
+/// \brief Dispatcher, to send MC events out on the network
+///          
+/// \author A Mastbaum <mastbaum@hep.upenn.edu>
+///
+/// REVISION HISTORY:\n
+///     11 Nov 2011 : A Mastbaum - first revision
+///
+///  \detail
+///
+////////////////////////////////////////////////////////////////////
+#ifndef __RAT_DispatchEvents___
+#define __RAT_DispatchEvents___
+
+#include <RAT/Processor.hh>
+#include <RAT/avalanche.hpp>
+
+namespace RAT {
+
+class DispatchEvents : public Processor {
+public:
+  DispatchEvents();
+  virtual ~DispatchEvents();
+  virtual Processor::Result DSEvent(DS::Root* ds);
+
+  // address - string, name of the socket for output
+  // e.g. "tcp://localhost:7777"
+  virtual void SetS(std::string param, std::string value);
+  
+protected:
+  bool fSentRunHeaders;
+  std::string address;
+  avalanche::server* serv;
+};
+
+} // namespace RAT
+
+#endif
+
Index: src/io/PackEvents.cc
===================================================================
--- src/io/PackEvents.cc	(revision 650)
+++ src/io/PackEvents.cc	(working copy)
@@ -1,15 +1,16 @@
 ////////////////////////////////////////////////////////////////////
 // Last svn revision: $Id$
 ////////////////////////////////////////////////////////////////////
+
 #include <RAT/PackEvents.hh>
-#include <RAT/DS/PackedEvent.hh>
+#include <RAT/Pack.hh>
 #include <RAT/Log.hh>
 #include <RAT/Processor.hh>
-#include <RAT/DB.hh>
+#include <RAT/BitManip.hh>
+#include <RAT/DS/PackedEvent.hh>
 #include <RAT/DS/RunStore.hh>
 #include <RAT/DS/Run.hh>
 #include <RAT/DS/HeaderInfo.hh>
-#include <RAT/BitManip.hh>
 
 #include <G4UImessenger.hh>
 #include <TFile.h>
@@ -17,581 +18,102 @@
 
 namespace RAT {
 
-const int Nheader = 6;
-
 PackEvents::PackEvents() : Processor("PackEvents")
 {
-  // VERSION NUMBER FOR THIS CODE: UPDATE WITH ANY STRUCT CHANGES!
-  fPackVer = 0;
-  
-  // Counter for N events
   fEVID = 0;
-  
-  fFile = 0;
+  fFile = NULL;
   fAutosave = 1024; // kB
-  branchPackedEv = new DS::PackedEvent();
-  branchPackedRec = new DS::PackedRec();
-  
-  fBits = new BitManip();
-
-  // Extract default filename from database.  Used if no
-  // output file is specified by user with /rat/procset
-  DBLinkPtr roottab = DB::Get()->GetLink("ROOT");
-  try {
-    fDefaultFileName = roottab->GetS("filename");
-  } catch (DBNotFoundError &e) { 
-    fDefaultFileName = "out.root";
-  }
+  fBranchRec = new DS::PackedRec();
 }
 
 PackEvents::~PackEvents()
 {
-  if (fFile) {
     fFile->cd();
     fTree->Write();
-    //DS::RunStore::FlushWriteTree();
-    fFile->Close(); // also deletes TTree?
+    fFile->Close();
 
     delete fFile;
-  }
-  
-  // Don't delete branchDS because it looks like the TTree took ownership of it
 }
 
 void PackEvents::SetS(std::string param, std::string value)
 {
   if (param == "file") {
-      //if (fRunNum > 0) {
-	//  std::ostringstream buffer;
-	//  char temp_str[16];
-	//  snprintf(temp_str, sizeof(temp_str), "_%04i.root",100000);
-	//  buffer << value << temp_str; 
-	//  value = buffer.str();
-      //}
-      if (!OpenFile(value))
-         Log::Die("PackEvents: Cannot open file " + value);
-  } 
+    info << "PackEvents: Writing to " << value << newline;
+    fFile = TFile::Open(value.c_str(), "recreate");
+    Log::Assert(fFile, "PackEvents: Unable to open output file");
+
+    // Set up tree
+    fTree = new TTree("PackT", "RAT Tree");	
+    fTree->Branch("PackRec", fBranchRec->ClassName(), &fBranchRec, 32000, 99);
+
+    // Allow tree to be recovered up to last N kilobytes if RAT terminates suddenly
+    fTree->SetAutoSave(fAutosave*1024);
+  }
 }
 
 void PackEvents::SetI(std::string param, int value)
 {
   if (param == "autosave") {
-    if (value <= 0)
-       Log::Die("PackEvents: autosave parameter must be a postive integer");
+    Log::Assert(value > 0, "PackEvents: autosave parameter must be a postive integer");
       
     fAutosave = value;
     if (fTree) // fAutosave might be called after the file is already opened
-       fTree->SetAutoSave(fAutosave*1024 /*bytes*/); 
+       fTree->SetAutoSave(fAutosave*1024);
   }
 }
 
-bool PackEvents::OpenFile(std::string theFilename)
+Processor::Result PackEvents::DSEvent(DS::Root* ds)
 {
-  info << "PackEvents: Writing to " << theFilename << newline;
-  fFile = TFile::Open(theFilename.c_str(), "RECREATE");
-
-  if (!fFile)
-     return false;
-
-  fFileName = theFilename;
-
-  // Setup tree
-  fTree = new TTree("PackT", "RAT Tree");	
-  fTree->Branch("PackRec", branchPackedRec->ClassName(), &branchPackedRec, 32000, 99);
-
-  // Allow tree to be recovered up to last N kilobytes if RAT terminates suddenly
-  fTree->SetAutoSave(fAutosave*1024 /*bytes*/); 
+  Log::Assert(fFile, "PackEvents: Output file required");
   
-  return true;
-}
-
-
-Processor::Result PackEvents::DSEvent(DS::Root *ds)
-{
-  if(!fFile){
-    // Assume no file specified, and so we must open the default
-    info << "PackEvents: No output file specified, opening " << fDefaultFileName
-	  << newline;
-    if (!OpenFile(fDefaultFileName))
-      Log::Die("PackEvents: No output file specified and cannot open default: "
-		  +fDefaultFileName);
-  }
-  
   // If we're on the first event, fill the initial header information
-  if(fEVID == 0){
-    PackEvents::MakeRunHeader(ds);
-  }
-  
-  // If this ds event has event-level info attached, make more headers
-  if(ds->ExistHeaderInfo()){
-    PackEvents::MakeEventHeader(ds);
-  }
-
-  // Loop over triggered events
-  for (int iev=0; iev<ds->GetEVCount(); ++iev){
-    DS::EV *ev = ds->GetEV(iev);
-
-    // Get Run level info
-    DS::Run *run = RAT::DS::RunStore::GetRun(ds);
-    int runID = run->GetRunID();
-    int subRunID = run->GetSubRunID();
-    fRunType = run->GetRunType();
-    fMCFlag = run->GetMCFlag();
-    fDataType = run->GetDataType();
-  
-    // Get Root level info
-    fRunID = ds->GetRunID();
-    fSubRunID = ds->GetSubRunID();
-    if(fSubRunID!=subRunID)G4cout<<"subRun IDs DO NOT MATCH: "<<fSubRunID<<" & "<<subRunID<<G4endl;
-    if(fRunID!=runID)G4cout<<"RUN IDs DO NOT MATCH: "<<fRunID<<" & "<<runID<<G4endl;
-    
-    // Create instance of PackedEvent, and PackedRec branch
-    DS::PackedEvent *PackedEV;
-    DS::PackedRec *PackedRec = new DS::PackedRec();
-
-    // Pack the event info
-    PackedEV = PackEvents::PackEvent(ev);
-    PackedRec->RecordType = 1;
-    
-    // Write to tree
-    PackedRec->Rec = new DS::PackedEvent();
-    PackedRec->Rec = PackedEV;
-    branchPackedRec = PackedRec;
+  if (fEVID == 0) {
+    fBranchRec = Pack::MakeRunHeader(ds);
     fTree->Fill();
-    delete PackedRec->Rec;
-    delete PackedRec;
-    //delete PackedEV;
-    ++fEVID;
-  }
+    delete fBranchRec;
   
-  return Processor::OK;
-}
+    // If AVStat / ManipStat are filled, make CAAC/CAST headers:
+    DS::Run* run = RAT::DS::RunStore::GetRun(ds);
 
-// Fill event-level header information
-void PackEvents::MakeEventHeader(DS::Root *ds)
-{
-  DS::HeaderInfo *header = ds->GetHeaderInfo();
-  
-  // Make appropriate headers, if info exists
-  if(header->ExistTRIGInfo()){
-    DS::TRIGInfo *trig = header->GetTRIGInfo();
-    PackEvents::MakeTRIGHeader(trig);
-  }
+    if (run->ExistManipStat()) {
+      fBranchRec = Pack::MakeManipHeader(ds);
+      fTree->Fill();
+      delete fBranchRec;
+    }
 
-  if(header->ExistEPEDInfo()){
-    DS::EPEDInfo *eped = header->GetEPEDInfo();
-    PackEvents::MakeEPEDHeader(eped);
+    if (run->ExistAVStat()) {
+      fBranchRec = Pack::MakeAVHeader(ds);
+      fTree->Fill();
+      delete fBranchRec;
+    }
   }
   
-  return;
-}
+  // If this ds event has event-level info attached, make more headers
+  if (ds->ExistHeaderInfo()) {
+    if (ds->GetHeaderInfo()->ExistTRIGInfo()) {
+      fBranchRec = Pack::MakeTRIGHeader(ds);
+      fTree->Fill();
+      delete fBranchRec;
+    }
 
-void PackEvents::MakeTRIGHeader(DS::TRIGInfo *trig)
-{
-  // Create instance of generic record type, and set type for trig
-  DS::PackedRec *PackedRec = new DS::PackedRec();
-  PackedRec->RecordType = 5;
-    
-  // Fill header info
-  DS::TRIG *thisRec = new DS::TRIG();
-  thisRec->TrigMask = trig->GetTrigMask();
-  thisRec->PulserRate = trig->GetPulserRate();
-  thisRec->MTC_CSR = trig->GetMTC_CSR();
-  thisRec->LockoutWidth = trig->GetLockoutWidth();
-  thisRec->PrescaleFreq = trig->GetPrescaleFreq();
-  thisRec->EventID = trig->GetEventID();
-  thisRec->RunID = trig->GetRunID();
-  
-  int ntrigthold = trig->GetNTrigTHold();
-  int ntrigzero = trig->GetNTrigZeroOffset();
-  for(int i=0;i<10;++i){
-    thisRec->Threshold[i] = 0;
-    thisRec->TrigZeroOffset[i] = 0;
-    if(i<ntrigthold)thisRec->Threshold[i] = trig->GetTrigTHold(i);
-    if(i<ntrigzero)thisRec->TrigZeroOffset[i] = trig->GetTrigZeroOffset(i);
+    if (ds->GetHeaderInfo()->ExistEPEDInfo()) {
+      fBranchRec = Pack::MakeEPEDHeader(ds);
+      fTree->Fill();
+      delete fBranchRec;
+    }
   }
 
-  // Fill tree
-  PackedRec->Rec = new DS::TRIG();
-  PackedRec->Rec = thisRec;
-  branchPackedRec = PackedRec;
-  fTree->Fill();
-  delete PackedRec->Rec;
-  //delete thisRec;
-  delete PackedRec;
-  
-  return;
-}
-
-
-void PackEvents::MakeEPEDHeader(DS::EPEDInfo *eped)
-{
-  // Create instance of generic record type, and set type for eped
-  DS::PackedRec *PackedRec = new DS::PackedRec();
-  PackedRec->RecordType = 6;
-    
-  // Fill header info
-  DS::EPED *thisRec = new DS::EPED();
-  thisRec->GTDelayCoarse = eped->GetGTDelayCoarse();
-  thisRec->GTDelayFine = eped->GetGTDelayFine();
-  thisRec->QPedAmp = eped->GetQPedAmp();
-  thisRec->QPedWidth = eped->GetQPedWidth();
-  thisRec->PatternID = eped->GetPatternID();
-  thisRec->CalType = eped->GetCalType();
-  thisRec->EventID = eped->GetEventID();
-  thisRec->RunID = eped->GetRunID();
-
-  // Fill tree
-  PackedRec->Rec = new DS::EPED();
-  PackedRec->Rec = thisRec;
-  branchPackedRec = PackedRec;
-  fTree->Fill();
-  delete PackedRec->Rec;
-  //delete thisRec;
-  delete PackedRec;
-  
-  return;
-}
-
-
-// Fill run header information
-void PackEvents::MakeRunHeader(DS::Root *ds)
-{
-  // Get run-level info
-  DS::Run *run = RAT::DS::RunStore::GetRun(ds);
-  
-  // Create instance of generic record type, and set type for run header
-  DS::PackedRec *PackedRec = new DS::PackedRec();
-  PackedRec->RecordType = 2;
-    
-  // Fill header info
-  DS::RHDR *thisRec = new DS::RHDR();
-  thisRec->Date = run->GetDate();
-  thisRec->Time = run->GetTime();
-  thisRec->DAQVer = run->GetDAQVer();
-  thisRec->CalibTrialID = run->GetCalibTrialID();
-  thisRec->SrcMask = run->GetSrcMask();
-  thisRec->RunMask = run->GetRunType();
-  thisRec->CrateMask = run->GetCrateMask();
-  thisRec->FirstEventID = run->GetFirstEventID();
-  thisRec->ValidEventID = run->GetValidEventID();
-  thisRec->RunID = run->GetRunID();
-
-  // Fill tree
-  PackedRec->Rec = new DS::RHDR();
-  PackedRec->Rec = thisRec;
-  branchPackedRec = PackedRec;
-  fTree->Fill();
-  delete PackedRec->Rec;
-  ////delete thisRec;
-  delete PackedRec;
-  
-  // If AVStat / ManipStat are filled, make CAAC/CAST headers:
-  if(run->ExistManipStat())PackEvents::MakeManipHeader(run);
-  if(run->ExistAVStat())PackEvents::MakeAVHeader(run);
-
-  return;
-}
-
-void PackEvents::MakeAVHeader(DS::Run *run)
-{
-  // Get AV status info
-  DS::AVStat *avstat = run->GetAVStat();
-  
-  // Create instance of generic record type, and set type for AV header
-  DS::PackedRec *PackedRec = new DS::PackedRec();
-  PackedRec->RecordType = 3;
-    
-  // Fill header info
-  DS::CAAC *thisRec = new DS::CAAC();
-  for(int i=0;i<3;++i){
-    thisRec->AVPos[i] = avstat->GetPosition(i);
-    thisRec->AVRoll[i] = avstat->GetRoll(i);
+  // Loop over triggered events
+  for (int iev=0; iev<ds->GetEVCount(); iev++) {
+    fBranchRec = Pack::PackEvent(ds, iev);
+    fTree->Fill();
+    delete fBranchRec;
   }
-  for(int i=0;i<7;++i){
-    thisRec->AVRopeLength[i] = avstat->GetRopeLength(i);
-  }
 
-  // Fill tree
-  PackedRec->Rec = new DS::CAAC();
-  PackedRec->Rec = thisRec;
-  branchPackedRec = PackedRec;
-  fTree->Fill();
-  delete PackedRec->Rec;
-  //delete thisRec;
-  delete PackedRec;
+  fEVID++;
 
-  return;
+  return Processor::OK;
 }
 
-void PackEvents::MakeManipHeader(DS::Run *run)
-{
-  // Get Manipulator status info
-  DS::ManipStat *manipstat = run->GetManipStat();
-  
-  // Create instance of generic record type, and set type for Manip header
-  DS::PackedRec *PackedRec = new DS::PackedRec();
-  PackedRec->RecordType = 4;
-    
-  // Fill header info
-  DS::CAST *thisRec = new DS::CAST();
-  for(int i=0;i<3;++i){
-    thisRec->ManipPos[i] = manipstat->GetManipPos(i);
-    thisRec->ManipDest[i] = manipstat->GetManipDest(i);
-    thisRec->SrcPosUncert2[i] = manipstat->GetSrcPosUnc(i);
-  }
-  thisRec->SourceID = manipstat->GetSrcID();
-  thisRec->SourceStat = manipstat->GetSrcStatus();
-  thisRec->NRopes = manipstat->GetNRopes();
-  thisRec->SrcPosUncert1 = manipstat->GetSrcPosUnc();
-  thisRec->LBallOrient = manipstat->GetLaserballOrient();
-
-  int nrope = manipstat->GetNRopes();
-  thisRec->RopeID.resize(nrope);
-  thisRec->RopeLen.resize(nrope);
-  thisRec->RopeTargLen.resize(nrope);
-  thisRec->RopeVel.resize(nrope);
-  thisRec->RopeTens.resize(nrope);
-  thisRec->RopeErr.resize(nrope);
-  for(int i=0; i<nrope;++i){
-    thisRec->RopeID[i] = manipstat->GetRopeID(i);
-    thisRec->RopeLen[i] = manipstat->GetRopeLength(i);
-    thisRec->RopeTargLen[i] = manipstat->GetRopeTargLength(i);
-    thisRec->RopeVel[i] = manipstat->GetRopeVelocity(i);
-    thisRec->RopeTens[i] = manipstat->GetRopeTension(i);
-    thisRec->RopeErr[i] = manipstat->GetRopeErr(i);
-  }
-
-  // Fill tree
-  PackedRec->Rec = new DS::CAST();
-  PackedRec->Rec = thisRec;
-  branchPackedRec = PackedRec;
-  fTree->Fill();
-  delete PackedRec->Rec;
-  //delete thisRec;
-  delete PackedRec;
-
-  return;
-}
-
-// Pack the event
-DS::PackedEvent* PackEvents::PackEvent(DS::EV *ev)
-{
-  DS::PackedEvent *PackedEV;
-  PackedEV = PackEvents::PackHeader(ev);
-  
-  int npmtall = ev->GetPMTAllUnCalCount();
-  int npmtuncal = ev->GetPMTUnCalCount();
-  int nhits = ev->GetNhits();
-  if(npmtuncal != nhits)PackEvents::Die("",1,nhits,npmtuncal);
-  
-  // Set number of PMT bundles
-  PackedEV->PMTBundles.resize(npmtall);
-  int eventID = ev->GetEventID();
-  
-  // Pack each bundle
-  for(int inh=0; inh<npmtall; ++inh){
-    DS::PMTUnCal *pmt = ev->GetPMTAllUnCal(inh);
-    //DS::PMTBundle PMTBundle;
-    PackedEV->PMTBundles[inh] = PackEvents::PackPMT(pmt, eventID);
-  }
-
-  return PackedEV;
-}
-
-
-// Pack the event header info
-DS::PackedEvent* PackEvents::PackHeader(DS::EV *ev)
-{
-  DS::PackedEvent *PackedEV = new DS::PackedEvent();
-  
-  // Get event level info
-  UInt_t trigError = ev->GetTrigError();
-  UInt_t trigType = ev->GetTrigType();
-  UInt_t eventID = ev->GetEventID();
-  ULong64_t clockCount50 = ev->GetClockCount50();
-  ULong64_t clockCount10 = ev->GetClockCount10();
-  char clockStat10 = ev->GetClockStat10();
-  int nhits = ev->GetNhits();
-  
-  // Init header words
-  int header[Nheader];
-  for(int i=0;i<Nheader;++i){
-    header[i] = 0;
-  }
-
-  // Check some lengths:
-  if(!fBits->CheckLength((UInt_t)fRunType, 16))PackEvents::Die("RunType",2,fRunType,0);
-  if(!fBits->CheckLength(nhits, 16))PackEvents::Die("NHits",2,nhits,0);
-  if(!fBits->CheckLength(clockStat10, 4))PackEvents::Die("ClockStat10",2,clockStat10,0);
-  if(!fBits->CheckLength(eventID, 24))PackEvents::Die("GTID",2,eventID,0);
-  if(!fBits->CheckLength(trigError, 15))PackEvents::Die("TrigError",2,trigError,0);
-
-  // Pack header words
-  ULong64_t Lclock50part1 = fBits->GetBits(clockCount50, 0, 11);
-  ULong64_t Lclock50part2 = fBits->GetBits(clockCount50, 11, 32);
-  ULong64_t Lclock10part1 = fBits->GetBits(clockCount10, 0, 32);
-  ULong64_t Lclock10part2 = fBits->GetBits(clockCount10, 32, 21);
-  UInt_t clock50part1 = (UInt_t)Lclock50part1;
-  UInt_t clock50part2 = (UInt_t)Lclock50part2;
-  UInt_t clock10part1 = (UInt_t)Lclock10part1;
-  UInt_t clock10part2 = (UInt_t)Lclock10part2;
-  if(!fBits->CheckLength(clock50part1, 11))PackEvents::Die("clock50part1",2,clock50part1,0);
-  if(!fBits->CheckLength(clock50part2, 32))PackEvents::Die("clock50part2",2,clock50part2,0);
-  if(!fBits->CheckLength(clock10part1, 32))PackEvents::Die("clock10part1",2,clock10part1,0);
-  if(!fBits->CheckLength(clock10part2, 21))PackEvents::Die("clock10part2",2,clock10part2,0);
-  
-  ULong64_t test10 = 0;
-  ULong64_t p1 = (ULong64_t)clock10part1;
-  ULong64_t p2 = (ULong64_t)clock10part2;
-  test10 = (p2<<32)+p1;
-  if(test10!=clockCount10)G4cout<<"\033[34m COUNTS DONT MATCH! \033[m"<<G4endl;
-  
-  header[0] = clock10part1;                                      // 32 bits of 10MHz clock
-  header[1] = clock10part2;                                      // 21 bits of ""
-  header[1] = fBits->SetBits(header[1], 21, clock50part1);  // 11 bits of 50MHz clock 
-  header[2] = clock50part2;                                      // 32 bits of ""
-
-  unsigned int trig1 = fBits->GetBits(trigType, 0, 8);
-  unsigned int trig2 = fBits->GetBits(trigType, 8, 19);
-  if(!fBits->CheckLength(trigType, 27))PackEvents::Die("TrigWord",2,trigType,0);
-  if(!fBits->CheckLength(trig1, 8))PackEvents::Die("TrigWordP1",2,trig1,0);
-  if(!fBits->CheckLength(trig2, 19))PackEvents::Die("TrigWordP2",2,trig2,0);
-  
-  header[3] = eventID;                                           // 24 bits of GTID
-  header[3] = fBits->SetBits(header[3], 24, trig1);         // 8 bits of Trigger word
-  header[4] = trig2;                                             // 19 bits of Trigger word
-  header[5] = fBits->SetBits(header[5], 17, trigError);   // 15 bits of TrigError wd
-  
-  for(int i=0;i<Nheader;++i){
-    PackedEV->MTCInfo[i] = header[i];
-  }
-  
-  PackedEV->DataType = fDataType;
-  PackedEV->MCFlag = fMCFlag;
-  PackedEV->PackVer = fPackVer;
-  PackedEV->RunMask = fRunType;
-  PackedEV->RunID = fRunID;
-  PackedEV->EVOrder = fEVID;
-  PackedEV->SubRunID = fSubRunID;
-  PackedEV->NHits = nhits;
-  PackedEV->ClockStat10 = clockStat10;
-
-  return PackedEV;
-}
-
-
-// Pack the PMT Bundles
-DS::PMTBundle PackEvents::PackPMT(DS::PMTUnCal *pmt, unsigned int gtid)
-{
-  DS::PMTBundle PMTBundle;
-  PMTBundle.Word[0] = 0;
-  PMTBundle.Word[1] = 0;
-  PMTBundle.Word[2] = 0;
-  int word1 = 0;
-  int word2 = 0;
-  int word3 = 0;
-    
-  // Get PMT level info
-  int lcn = pmt->GetID();
-  int icrate = fBits->GetCrate(lcn);
-  int icard = fBits->GetCard(lcn);
-  int ichan = fBits->GetChannel(lcn);
-  int cell = pmt->GetCellID();
-  char chanFlags = pmt->GetChanFlags();
-  // Order of flags in chanFlags, from least sig bit upwards:
-  // CGT ES16, CGT ES24, Missed Count, NC/CC Flag, LGISELECT, CMOS ES16
-
-  // Get uncalibrated charges and time
-  unsigned short qhs = pmt->GetsQHS();
-  unsigned short qhl = pmt->GetsQHL();
-  unsigned short qlx = pmt->GetsQLX();
-  unsigned short tac = pmt->GetsPMTt();
-  
-  // Flip final bit of Q,T (to mimic the fact that the ADCs are just plain weird)
-  BitManip bits;
-  qhs = bits.FlipBit(qhs,11);
-  qhl = bits.FlipBit(qhl,11);
-  qlx = bits.FlipBit(qlx,11);
-  tac = bits.FlipBit(tac,11);
-
-  // Check some lengths:
-  if(!fBits->CheckLength(qlx, 12))PackEvents::Die("QLX",2,qlx,0); // QLX was > 12 bits????
-  if(!fBits->CheckLength(qhs,12))PackEvents::Die("QHS",2,qhs,0);    // QHS was > 12 bits????
-  if(!fBits->CheckLength(qhl,12))PackEvents::Die("QHL",2,qhl,0);    // QHL was > 12 bits????
-  if(!fBits->CheckLength(tac,12))PackEvents::Die("TAC",2,tac,0);    // TAC was > 12 bits????
-  if(!fBits->CheckLength(cell,4))PackEvents::Die("CellID",2,cell,0);    // CellID was > 4 bits????
-  if(!fBits->CheckLength(icrate,5))PackEvents::Die("Crate#",2,icrate,0);    // CrateID was > 5 bits????
-  if(!fBits->CheckLength(icard,4))PackEvents::Die("Card#",2,icard,0);    // CardID was > 4 bits????
-  if(!fBits->CheckLength(ichan,5))PackEvents::Die("Channel#",2,ichan,0);    // ChanID was > 5 bits????
-  
-  // Pack this bundle
-  
-  // First word
-  word1 = fBits->GetBits(gtid, 0, 16);       // 16 bits of GTID
-  word1 = fBits->SetBits(word1, 16, ichan);  // 5 bits of ichan
-  word1 = fBits->SetBits(word1, 21, icrate); // 5 bits of icrate
-  word1 = fBits->SetBits(word1, 26, icard);  // 4 bits of icard
-  if(fBits->TestBit(chanFlags,0)){           // 1 bit for CGT ES16
-    word1 = fBits->SetBit(word1, 30);
-  }
-  if(fBits->TestBit(chanFlags,1)){           // 1 bit for CGT ES24
-    word1 = fBits->SetBit(word1, 31);
-  }
-  
-  // Second word  
-  word2 = qlx;                                    // 12 bits for QLX
-  word2 = fBits->SetBits(word2, 12, cell);   // 4 bits for cellID
-  word2 = fBits->SetBits(word2, 16, qhs);    // 12 bits for QHS
-  if(fBits->TestBit(chanFlags,2)){           // 1 bit for `Missed count'
-    word2 = fBits->SetBit(word2, 28);
-  }
-  if(fBits->TestBit(chanFlags,3)){           // 1 bit for NC/CC
-    word2 = fBits->SetBit(word2, 29);
-  }
-  if(fBits->TestBit(chanFlags,4)){           // 1 bit for LGISelect
-    word2 = fBits->SetBit(word2, 30);
-  }
-  if(fBits->TestBit(chanFlags,5)){           // 1 bit for CMOS ES16
-    word2 = fBits->SetBit(word2, 31);
-  }
-  
-  // Third word
-  int gtidpart1 = fBits->GetBits(gtid, 16, 4);
-  int gtidpart2 = fBits->GetBits(gtid, 20, 4);
-  word3 = qhl;                                         // 12 bits for QHL
-  word3 = fBits->SetBits(word3, 12, gtidpart1);   // 4 bits of GTID
-  word3 = fBits->SetBits(word3, 16, tac);         // 12 bits for TAC
-  word3 = fBits->SetBits(word3, 28, gtidpart2);   // 4 bits of GTID
-
-  PMTBundle.Word[0] = word1;
-  PMTBundle.Word[1] = word2;
-  PMTBundle.Word[2] = word3;
-  return PMTBundle;
-  
-}
-
-
-// Handle FATAL errors
-void PackEvents::Die(std::string message, int flag_err, int info1, int info2, int return_code)
-{
-  warn << "\033[31m PACKING PROBLEM: \033[m" <<newline;
-
-  if(flag_err==1){  // NHit != NPMTUnCal
-    warn <<"Discrepancy in # events:"<<newline;
-    warn<<"We have "<<info1<<" NHit but "<<info2<<" PMTUnCal in this event"<<newline;
-    warn<<"Something is wrong."<<newline;
-    warn<<newline;
-  }
-
-  if(flag_err==2){  // Word is wrong length!
-    warn <<"Discrepancy in length of integer"<<newline;
-    warn <<message<<" value is "<<info1<<newline;
-    warn<<"Something is wrong."<<newline;
-    warn<<newline;
-  }
-  exit(return_code);
-}
-  
-
 } // namespace RAT
+
Index: src/io/InDispatchProducer.hh
===================================================================
--- src/io/InDispatchProducer.hh	(revision 0)
+++ src/io/InDispatchProducer.hh	(revision 0)
@@ -0,0 +1,66 @@
+////////////////////////////////////////////////////////////////////
+// Last svn revision: $Id: UnPackEvents.hh 628 2011-10-17 16:53:43Z orebi $
+////////////////////////////////////////////////////////////////////
+/// \class RAT::InDispatchProducer
+///
+/// \brief Read events from the dispatcher stream into RAT
+///          
+/// \author A. Mastbaum <mastbaum@hep.upenn.edu>
+///
+/// REVISION HISTORY:\n
+///     19 Dec 2011 : A Mastbaum - initial version
+///
+///  \detail  This producers reads in packed events from the dispatcher
+///           stream, output by the event builder or the RAT
+///           DispatchEvents processor, and populates the full RAT DS.
+///
+///           Unlike the InPackedProducer, this will ignore corrupted
+///           records and continue.
+///
+////////////////////////////////////////////////////////////////////
+
+#ifndef __RAT_InDispatchProducer__
+#define __RAT_InDispatchProducer__
+
+#include <RAT/Producer.hh>
+#include <globals.hh>
+
+class G4UIcmdWithAString;
+
+namespace RAT {
+
+#ifdef __ZMQ
+
+class InDispatchProducer : public Producer {
+public:
+  InDispatchProducer(ProcBlock* block);
+  virtual ~InDispatchProducer() {};
+
+  virtual bool ReadEvents(G4String address);
+  virtual void SetNewValue(G4UIcommand* command, G4String newValue);
+
+protected:
+  G4UIcmdWithAString* fReadCmd;
+};
+
+#else
+
+class InDispatchProducer : public Producer {
+public:
+  InDispatchProducer(ProcBlock* block) {};
+  virtual ~InDispatchProducer() {};
+
+  virtual bool ReadEvents(G4String address) { Die(); }
+  virtual void SetNewValue(G4UIcommand* command, G4String newValue) { Die(); }
+
+  void Die()
+  {
+    Log::Die("InDispachProducer: ZeroMQ support required.");
+  }
+};
+
+#endif
+
+} // namespace RAT
+
+#endif
Index: src/io/UnPackEvents.cc
===================================================================
--- src/io/UnPackEvents.cc	(revision 650)
+++ src/io/UnPackEvents.cc	(working copy)
@@ -1,599 +0,0 @@
-////////////////////////////////////////////////////////////////////
-// Last svn revision: $Id$ 
-////////////////////////////////////////////////////////////////////
-
-#include <RAT/UnPackEvents.hh>
-#include <RAT/ProcBlock.hh>
-#include <RAT/DS/PackedEvent.hh>
-#include <RAT/DS/Root.hh>
-#include <RAT/DS/Run.hh>
-#include <RAT/DS/EV.hh>
-#include <RAT/DS/RunStore.hh>
-#include <RAT/SignalHandler.hh>
-#include <RAT/Log.hh>
-#include <RAT/DB.hh>
-#include <RAT/BitManip.hh>
-
-#include <G4UIdirectory.hh>
-#include <G4UIcmdWithAString.hh>
-
-#include <TChain.h>
-#include <TFile.h>
-#include <TTree.h>
-
-#include <assert.h>
-
-namespace RAT {
-
-
-UnPackEvents::UnPackEvents()
-{
-  fMainBlock = 0;
-  Init();
-}
-
-UnPackEvents::UnPackEvents(ProcBlock *block)
-{
-  SetMainBlock(block);
-  Init();
-}
-
-UnPackEvents::~UnPackEvents()
-{
-}
-
-void UnPackEvents::Init()
-{
-  // Build commands
-  G4UIdirectory* DebugDir = new G4UIdirectory("/rat/unpack/");
-  DebugDir->SetGuidance("Read Events from ROOT file");
-
-  // info message command
-  fReadCmd = new G4UIcmdWithAString("/rat/unpack/read", this);
-  fReadCmd->SetGuidance("name of input file");
-  fReadCmd->SetParameterName("filename", false);  // required
-  
-  DBLinkPtr PMTBank= DB::Get()->GetLink("PMTINFO");
-  fPMTtype = PMTBank->GetIArray("type");
-  
-  fEventID = -1;
-  fRunID = 0;
-  fRunMask = 0;
-  fEvRHDR = -1;
-  fCheckRHDR = false;
-  fEvTRIG = -1;
-  fCheckTRIG = false;
-  fEvEPED = -1;
-  fCheckEPED = false;
-  fBits = new BitManip();
-}
-
-G4String UnPackEvents::GetCurrentValue(G4UIcommand * /* command*/)
-{
-  Log::Die("invalid unpack \"get\" command");
-  return G4String("You never see this.");
-}
-
-
-void UnPackEvents::SetNewValue(G4UIcommand * command, G4String newValue)
-{
-  // fReadCmd
-  if (command == fReadCmd) {
-     if (!fMainBlock)
-        Log::Die("Unpacker: No main block declared! (should never happen)");
-     else if (!ReadEvents(newValue))
-        Log::Die("Unpacker: Error reading event tree from " + newValue);
-  } else
-     Log::Die("invalid unpack \"set\" command");
-}
-
-bool UnPackEvents::ReadEvents(G4String filename)
-{
-  // Setup
-//  TFile *file = new TFile(filename.c_str());
-//  TTree *tree = (TTree *)file->Get("PackT");
-//  if (!tree->Add(filename.c_str()))
-//    return false;
-
-  TChain *tree = new TChain("PackT");
-  if (!tree->Add(filename.c_str()))
-    return false;
-
-  DS::PackedRec *branchRec = new DS::PackedRec();
-  tree->SetBranchAddress("PackRec", &branchRec);
-
-  // Read first event and populate run tree using AddNewRun()
-  int nentry = 0;
-  tree->GetEntry(nentry);
-
-  while(branchRec->RecordType!=1){
-    ++nentry;
-    tree->GetEntry(nentry);
-  }
-  DS::PackedEvent *branch2PE = dynamic_cast<DS::PackedEvent *>(branchRec->Rec);
-
-  // Create a new run and set run level info
-  DS::Run *run = new DS::Run();
-  run->SetRunID(branch2PE->RunID);
-  run->SetSubRunID(branch2PE->SubRunID);
-  run->SetRunType(branch2PE->RunMask);
-  run->SetMCFlag(branch2PE->MCFlag);
-  run->SetPackVer(branch2PE->PackVer);
-  run->SetDataType(branch2PE->DataType);
-  DS::RunStore::AddNewRun(run);
-  
-  // Init check values
-  fRunID = run->GetRunID();
-  fRunMask = run->GetRunType();
-
-  unsigned int eventcount = 0;
-  // Loop over events and populate T tree with new DSs
-  Int_t num_events = tree->GetEntries();
-
-  // Empty DS branch;
-  RAT::DS::Root *ds = 0;
-//  Int_t i = 0;
-//  while(i < num_events && !SignalHandler::IsTermRequested()) {
-  for (Int_t i=0; i < num_events && !SignalHandler::IsTermRequested(); i++) {
-    tree->GetEntry(i);
-    G4cout<<"Entry "<<i<<" & event "<<eventcount<<G4endl;
-    
-    int recordType = branchRec->RecordType;
-    std::string hold = UnPackEvents::IdentifyRecord(recordType);
-    G4cout<<"We have a "<<hold.c_str()<<G4endl;
-    
-    if(recordType==0){
-      G4cout<<"RECORD "<<i<<" IS EMPTY: something is wrong with the input file"<<G4endl;
-      exit(0);
-    }
-    
-    // Run-level information, extract, fill runT and continue to next entry
-
-    if(recordType==2){ // run-level information, extract and continue
-      DS::RHDR *branchRHDR = dynamic_cast<DS::RHDR *>(branchRec->Rec);
-      UnPackEvents::UnPackRHDR(branchRHDR, run);
-      continue;
-    }
-    if(recordType==3){ // run-level information, extract and continue
-      DS::CAAC *branchCAAC = dynamic_cast<DS::CAAC *>(branchRec->Rec);
-      UnPackEvents::UnPackCAAC(branchCAAC, run);
-      continue;
-    }
-    if(recordType==4){ // run-level information, extract and continue
-      DS::CAST *branchCAST = dynamic_cast<DS::CAST *>(branchRec->Rec);
-      UnPackEvents::UnPackCAST(branchCAST, run);
-      continue;
-    }
-    
-    // Event-level information, so create the appropriate DS branch if nec
-    
-    if(recordType==5){ // event-level information, create ds branch if nec
-      DS::TRIG *branchTRIG = dynamic_cast<DS::TRIG *>(branchRec->Rec);
-      if(ds==0)ds = new RAT::DS::Root();
-      UnPackEvents::UnPackTRIG(branchTRIG, ds);
-      continue;
-    }
-    if(recordType==6){ // event-level information, create ds branch if nec
-      DS::EPED *branchEPED = dynamic_cast<DS::EPED *>(branchRec->Rec);
-      if(ds==0)ds = new RAT::DS::Root();
-      UnPackEvents::UnPackEPED(branchEPED, ds);
-      continue;
-    }
-    
-    // Now we should only be left with real detector events:
-    if(recordType!=1){
-      continue;
-    }
-    if(ds==0)ds = new RAT::DS::Root();
-    DS::PackedEvent *branchPE = dynamic_cast<DS::PackedEvent *>(branchRec->Rec);
-      
-    // Set root/ds level info
-    ds->SetRunID(branchPE->RunID);
-    ds->SetSubRunID(branchPE->SubRunID);
-    if(ds->GetRunID()!=(int)fRunID)UnPackEvents::Die("RunID, event",4,ds->GetRunID(),fRunID);
-    
-    // Get the event level info
-    fEVOrder = branchPE->EVOrder;
-    if(fEVOrder != eventcount)UnPackEvents::Die("",1,eventcount,fEVOrder);
-    fNHits = branchPE->NHits;
-    fClockStat10 = branchPE->ClockStat10;
-    for(int ih=0; ih<kNheaders;++ih){
-      fMTCInfo[ih] = branchPE->MTCInfo[ih];
-    }
-
-    // Create a new EV object, and fill with unpacked info
-    DS::EV *ev = ds->AddNewEV();
-    
-    UnPackEvents::UnpackHeader(ev);
-    
-    for(int inh = 0; inh<(int)branchPE->PMTBundles.size(); ++inh){
-    
-      // Get the next PMTBundle in line, and its 3 words
-      DS::PMTBundle bundle = branchPE->PMTBundles[inh];
-      for(int ip=0; ip<kNpmt; ++ip){
-        fWord[ip] = bundle.Word[ip];
-      }
-      
-      UInt_t ichan = fBits->GetBits(fWord[0], 16, 5);
-      UInt_t icard = fBits->GetBits(fWord[0], 26, 4);
-      UInt_t icrate = fBits->GetBits(fWord[0], 21, 5);
-      UInt_t lcn = fBits->GetLCN(icrate, icard, ichan);
-      int type = fPMTtype[lcn];
-      
-      // Create a new PMTUnCal, and fill it with unpacked info
-      DS::PMTUnCal *pmt = ev->AddNewPMTUnCal(type);
-      
-      UnPackEvents::UnpackPMT(pmt, lcn);
-    }
-    // Nhits should be set automatically by the addition of PMTUnCals
-    if(fNHits!=ev->GetNhits())UnPackEvents::Die("",2,fNHits,ev->GetNhits());
-      
-    fMainBlock->DSEvent(ds);
-    ds = 0;
-    ++eventcount;
-//    ds->Clear();
-  }
-
-  // Cleanup
-  delete ds;
-  delete branchRec;
-
-  return true;
-}
-
-bool UnPackEvents::CheckOrder(std::string id, int prev, int next, int header)
-{
-
-  // The GTID in the header should equal the GTID of the next event
-  //                           and
-  // IF the GTID did not wrap (which it does at 24 bits)
-  //                               be > the prev event
-  // Otherwise
-  //                               be < the prev event
-  
-  bool ok = true;
-
-  // Check wrap:
-  bool wrap = true;
-  if(next>prev)wrap = false;
-  
-  if(header!=next){ok = false;}
-  if(wrap && (header>=prev)){ok = false;}
-  if(!wrap && (header<=prev)){ok = false;}
-  if(!ok)UnPackEvents::Die(id, 5, prev, next, header);
-  return true;
-  
-}
-
-void UnPackEvents::UnPackRHDR(DS::RHDR *branchRHDR, DS::Run* &run)
-{
-  if(branchRHDR->RunID!=fRunID)UnPackEvents::Die("RunID, RHDR",4,branchRHDR->RunID,fRunID);
-  if(branchRHDR->RunMask!=fRunMask)UnPackEvents::Die("RunMask, RHDR",4,branchRHDR->RunMask,fRunMask);
-  run->SetDate(branchRHDR->Date);
-  run->SetTime(branchRHDR->Time);
-  run->SetDAQVer(branchRHDR->DAQVer);
-  run->SetCalibTrialID(branchRHDR->CalibTrialID);
-  run->SetSrcMask(branchRHDR->SrcMask);
-  run->SetRunType(branchRHDR->RunMask);
-  run->SetCrateMask(branchRHDR->CrateMask);
-  run->SetFirstEventID(branchRHDR->FirstEventID);
-  run->SetValidEventID(branchRHDR->ValidEventID);
-  run->SetRunID(branchRHDR->RunID);
-  fEvRHDR = branchRHDR->FirstEventID;
-  fCheckRHDR = true;
-
-  return;
-}
-
-void UnPackEvents::UnPackCAAC(DS::CAAC *branchCAAC, DS::Run* &run)
-{
-  // Check for existence of previous CAAC: there should not be 2 per run!
-  if(run->ExistAVStat())UnPackEvents::Die("AVStat",3,0,0);
-  // Get new AVStat object
-  DS::AVStat *avstat = run->GetAVStat();
-
-  for(int i=0;i<3;++i){
-    avstat->SetPosition(i, branchCAAC->AVPos[i]);
-    avstat->SetRoll(i, branchCAAC->AVRoll[i]);
-  }
-  for(int i=0;i<7;++i){
-    avstat->SetRopeLength(i, branchCAAC->AVRopeLength[i]);
-  }
-
-  return;
-}
-
-void UnPackEvents::UnPackCAST(DS::CAST *branchCAST, DS::Run* &run)
-{
-  // Check for existence of previous CAST: there should not be 2 per run!
-  if(run->ExistManipStat())UnPackEvents::Die("ManipStat",3,0,0);
-  // Get new ManipStat object
-  DS::ManipStat *manipstat = run->GetManipStat();
-
-  for(int i=0;i<3;++i){
-    manipstat->SetManipPos(i, branchCAST->ManipPos[i]);
-    manipstat->SetManipDest(i, branchCAST->ManipDest[i]);
-    manipstat->SetSrcPosUnc(i, branchCAST->SrcPosUncert2[i]);
-  }
-  manipstat->SetSrcID(branchCAST->SourceID);
-  manipstat->SetSrcStatus(branchCAST->SourceStat);
-  manipstat->SetNRopes(branchCAST->NRopes);
-  manipstat->SetSrcPosUnc(branchCAST->SrcPosUncert1);
-  manipstat->SetLaserballOrient(branchCAST->LBallOrient);
-
-  int nrope = branchCAST->NRopes;
-  for(int i=0; i<nrope;++i){
-    manipstat->SetRopeID(i, branchCAST->RopeID[i]);
-    manipstat->SetRopeLength(i, branchCAST->RopeLen[i]);
-    manipstat->SetRopeTargLength(i, branchCAST->RopeTargLen[i]);
-    manipstat->SetRopeVelocity(i, branchCAST->RopeVel[i]);
-    manipstat->SetRopeTension(i, branchCAST->RopeTens[i]);
-    manipstat->SetRopeErr(i, branchCAST->RopeErr[i]);
-  }
-
-  return;
-}
-
-void UnPackEvents::UnPackTRIG(DS::TRIG *branchTRIG, DS::Root* &ds)
-{
-  // Create a new headerInfo if one does not exist
-  DS::HeaderInfo *header = ds->GetHeaderInfo();
-  // Check for existence of previous TRIG: there should not be 2 per event!
-  if(header->ExistTRIGInfo())UnPackEvents::Die("TRIGInfo",3,0,0);
-  // Get new trig info object
-  DS::TRIGInfo *trig = header->GetTRIGInfo();
-
-  if(branchTRIG->RunID!=fRunID)UnPackEvents::Die("RunID, TRIG",4,branchTRIG->RunID,fRunID);
-  trig->SetTrigMask(branchTRIG->TrigMask);
-  trig->SetPulserRate(branchTRIG->PulserRate);
-  trig->SetMTC_CSR(branchTRIG->MTC_CSR);
-  trig->SetLockoutWidth(branchTRIG->LockoutWidth);
-  trig->SetPrescaleFreq(branchTRIG->PrescaleFreq);
-  trig->SetEventID(branchTRIG->EventID);
-  trig->SetRunID(branchTRIG->RunID);
-  
-  trig->SetNTrigTHold(10);
-  trig->SetNTrigZeroOffset(10);
-  for(int i=0;i<10;++i){
-    trig->SetTrigTHold(i, branchTRIG->Threshold[i]);
-    trig->SetTrigZeroOffset(i, branchTRIG->TrigZeroOffset[i]);
-  }
-
-  fEvTRIG = branchTRIG->EventID;
-  fCheckTRIG = true;
-
-  return;
-}
-
-void UnPackEvents::UnPackEPED(DS::EPED *branchEPED, DS::Root* &ds)
-{
-  // Create a new headerInfo if one does not exist
-  DS::HeaderInfo *header = ds->GetHeaderInfo();
-  // Check for existence of previous EPED: there should not be 2 per event!
-  if(header->ExistEPEDInfo())UnPackEvents::Die("EPEDInfo",3,0,0);
-  // Get new eped info object
-  DS::EPEDInfo *eped = header->GetEPEDInfo();
-
-  if(branchEPED->RunID!=fRunID)UnPackEvents::Die("RunID, EPED",4,branchEPED->RunID,fRunID);
-  eped->SetGTDelayCoarse(branchEPED->GTDelayCoarse);
-  eped->SetGTDelayFine(branchEPED->GTDelayFine);
-  eped->SetQPedAmp(branchEPED->QPedAmp);
-  eped->SetQPedWidth(branchEPED->QPedWidth);
-  eped->SetPatternID(branchEPED->PatternID);
-  eped->SetCalType(branchEPED->CalType);
-  eped->SetEventID(branchEPED->EventID);
-  eped->SetRunID(branchEPED->RunID);
-
-  fEvEPED = branchEPED->EventID;
-  fCheckEPED = true;
-  
-  return;
-}
-
-std::string UnPackEvents::IdentifyRecord(int input)
-{
-  std::string result;
-  if(input==0)result = "EMPTY";
-  if(input==1)result = "detector event";
-  if(input==2)result = "run header";
-  if(input==3)result = "AV status header";
-  if(input==4)result = "manipulator status header";
-  if(input==5)result = "TRIG bank header";
-  if(input==6)result = "EPED bank header";
-  return result;
-}
-
-void UnPackEvents::UnpackHeader(DS::EV *ev)
-{
-  // 6 MTCInfo words + clockstat10
-  ULong64_t clockCount50;
-  ULong64_t clockCount10;
-  UInt_t trigError;
-  UInt_t trigType;
-  UInt_t eventID;
-
-  ULong64_t clock10part1 = fMTCInfo[0];
-  ULong64_t clock10part2 = fBits->GetBits(fMTCInfo[1],0,21);
-  clockCount10 = (clock10part2 << 32) + clock10part1;
-
-  ULong64_t clock50part1 = fBits->GetBits(fMTCInfo[1],21,11);
-  ULong64_t clock50part2 = fMTCInfo[2];
-  clockCount50 = (clock50part2 << 11) + clock50part1;
-  
-  eventID = fBits->GetBits(fMTCInfo[3],0,24);
-  
-  UInt_t trigpart1 = fBits->GetBits(fMTCInfo[3],24,8);
-  UInt_t trigpart2 = fBits->GetBits(fMTCInfo[4],0,19);
-  trigType = (trigpart2 << 8) + trigpart1;
-  
-  trigError = fBits->GetBits(fMTCInfo[5],17,15);
-
-  // CHECK record ordering: we have the previous/current event's GTID (fEventID/eventID)
-  bool ok = true;
-  if(fCheckRHDR){
-    ok = UnPackEvents::CheckOrder("Run header",fEventID,eventID,fEvRHDR);
-    fCheckRHDR = false;
-  }
-  if(!ok)UnPackEvents::Die("Run header",6,0,0);
-  if(fCheckTRIG){
-    ok = UnPackEvents::CheckOrder("TRIGInfo", fEventID,eventID,fEvTRIG);
-    fCheckTRIG = false;
-  }
-  if(!ok)UnPackEvents::Die("TRIGInfo",6,0,0);
-  if(fCheckEPED){
-    ok = UnPackEvents::CheckOrder("EPEDInfo", fEventID,eventID,fEvEPED);
-    fCheckEPED = false;
-  }
-  if(!ok)UnPackEvents::Die("EPEDInfo",6,0,0);
-  
-  // Set eventID check value  
-  fEventID = eventID;
-
-  ev->SetClockStat10(fClockStat10);
-  ev->SetTrigError(trigError);
-  ev->SetTrigType(trigType);
-  ev->SetEventID(eventID);
-  ev->SetClockCount50(clockCount50);
-  ev->SetClockCount10(clockCount10);
-  
-    
-  // Set UT from 10MHz clock counts
-  ULong64_t Period = 100;  // 10MHz period in ns
-  ULong64_t Total = clockCount10 * Period;
-  ULong64_t NNsec = Total%(ULong64_t)1e9;
-  ULong64_t NSecs = Total/1e9;
-  ULong64_t NDays = NSecs/86400;
-  NSecs = NSecs - (86400*NDays);
-  
-  UInt_t ndays = (UInt_t)NDays;
-  UInt_t nsecs = (UInt_t)NSecs;
-  UInt_t nns = (UInt_t)NNsec;
-  
-  if(Total != (ULong64_t)NNsec + (ULong64_t)(1e9*NSecs) + (ULong64_t)(86400*1e9*NDays)){
-    //printf("\033[31m Total of %55u != %32u ns, %32u s, %32u d \033[m\n",Total, NNsec, NSecs, NDays);
-  }
-  
-  ev->SetUTDays(ndays);
-  ev->SetUTSecs(nsecs);
-  ev->SetUTNSecs(nns);
-  
-}
-
-void UnPackEvents::UnpackPMT(DS::PMTUnCal *pmt, int lcn)
-{
-  // 3 pmt words
-  UInt_t cell = fBits->GetBits(fWord[1], 12, 4);
-  
-  char chanflags = 0;
-  if(fBits->TestBit(fWord[0],30))chanflags = fBits->SetBit(chanflags,0);
-  if(fBits->TestBit(fWord[0],31))chanflags = fBits->SetBit(chanflags,1);
-  if(fBits->TestBit(fWord[1],28))chanflags = fBits->SetBit(chanflags,2);
-  if(fBits->TestBit(fWord[1],29))chanflags = fBits->SetBit(chanflags,3);
-  if(fBits->TestBit(fWord[1],30))chanflags = fBits->SetBit(chanflags,4);
-  if(fBits->TestBit(fWord[1],31))chanflags = fBits->SetBit(chanflags,5);
-  
-  UShort_t qhs = fBits->GetBits(fWord[1], 16, 12);
-  UShort_t qhl = fBits->GetBits(fWord[2], 0, 12);
-  UShort_t qlx = fBits->GetBits(fWord[1], 0, 12);
-  UShort_t tac = fBits->GetBits(fWord[2], 16, 12);
-  
-  // Flip final bit of Q,T (to fix the fact that the ADCs are just plain weird)
-  BitManip bits;
-  qhs = bits.FlipBit(qhs,11);
-  qhl = bits.FlipBit(qhl,11);
-  qlx = bits.FlipBit(qlx,11);
-  tac = bits.FlipBit(tac,11);
-  
-  // EventID is bits 0-15 of word 1, 12-15 and 28-31 of word3
-  Int_t evID = fBits->GetBits(fWord[0], 0, 16);
-  Int_t evID1 = fBits->GetBits(fWord[2], 12, 4);
-  Int_t evID2 = fBits->GetBits(fWord[2], 28, 4);
-  evID = evID + (evID1<<16) + (evID2<<20);
-  if(evID!=fEventID)UnPackEvents::Die("EventID, PMT",4,evID,fEventID);
-  
-  pmt->SetID(lcn);
-  pmt->SetCellID(cell);
-  pmt->SetChanFlags(chanflags);
-  pmt->SetsQHS(qhs);
-  pmt->SetsQHL(qhl);
-  pmt->SetsQLX(qlx);
-  pmt->SetsPMTt(tac);
-}
-
-
-// Handle FATAL errors
-void UnPackEvents::Die(std::string message, int flag_err, int info1, int info2, int info3, int return_code)
-{
-  warn << "\033[31m UNPACKING PROBLEM: \033[m" <<newline;
-
-  if(flag_err==1){  // Event out of order
-    warn <<"Discrepancy in event order:"<<newline;
-    warn<<"We're on event "<<info1<<" but it self-identifies as event "<<info2<<newline;
-    warn<<"Something is wrong."<<newline;
-    warn<<newline;
-  }
-
-  if(flag_err==2){  // NHits' don't match
-    warn <<"Discrepancy in NHits: "<<newline;
-    warn<<"This event claimed to have "<<info1<<" but we have added "<<info2<<" new PMTs"<<newline;
-    warn<<"Something is wrong."<<newline;
-    warn<<newline;
-  }
-
-  if(flag_err==3){  // 2 Header banks where there should be 1
-    std::string bank = "run";
-    if(message=="TRIGInfo"||message=="EPEDInfo")bank = "event";
-    warn <<"Discrepancy in header info: "<<newline;
-    warn<<"There are 2 "<<message<<" objects in this "<<bank;
-    warn<<" when there should be <=1!"<<newline;
-    warn<<"Something is wrong."<<newline;
-    warn<<newline;
-  }
-
-  if(flag_err==4){  // Unmatched Info
-    warn <<"Discrepancy in event/header info: "<<newline;
-    warn<<message<<" does not match up: "<<info1<<" & "<<info2<<newline;
-    warn<<"Something is wrong."<<newline;
-    warn<<newline;
-  }
-
-  if(flag_err==5){  // Records out of order
-    warn <<message<<" record in the packed file is out of order: "<<newline;
-    warn<<"Valid for event "<<info3<<newline;
-    warn<<"But comes between events "<<info1<<" & "<<info2<<" in the file"<<newline;
-    warn<<"Something is wrong."<<newline;
-    warn<<newline;
-  }
-
-  if(flag_err==6){  // Should never get here
-    warn <<"How did you even get here in the code???"<<newline;
-    warn<<"You should have died in the call to ``CheckOrder'' for "<<message<<newline;
-    warn<<"Something is wrong."<<newline;
-    warn<<newline;
-  }
-exit(return_code);
-}
-
-  
-
-} // namespace RAT
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
Index: src/io/InPackedProducer.cc
===================================================================
--- src/io/InPackedProducer.cc	(revision 0)
+++ src/io/InPackedProducer.cc	(revision 0)
@@ -0,0 +1,144 @@
+////////////////////////////////////////////////////////////////////
+// Last svn revision: $Id: UnPackEvents.cc 628 2011-10-17 16:53:43Z orebi $ 
+////////////////////////////////////////////////////////////////////
+
+#include <RAT/InPackedProducer.hh>
+#include <RAT/Pack.hh>
+#include <RAT/ProcBlock.hh>
+#include <RAT/DS/PackedEvent.hh>
+#include <RAT/DS/Root.hh>
+#include <RAT/DS/Run.hh>
+#include <RAT/DS/RunStore.hh>
+#include <RAT/SignalHandler.hh>
+#include <RAT/Log.hh>
+#include <RAT/DB.hh>
+
+#include <G4UIdirectory.hh>
+#include <G4UIcmdWithAString.hh>
+
+#include <TChain.h>
+
+namespace RAT {
+
+InPackedProducer::InPackedProducer(ProcBlock* block)
+{
+  SetMainBlock(block);
+
+  // build commands
+  G4UIdirectory* DebugDir = new G4UIdirectory("/rat/unpack/");
+  DebugDir->SetGuidance("Read packed-format events from a ROOT file");
+
+  // info message command
+  fReadCmd = new G4UIcmdWithAString("/rat/unpack/read", this);
+  fReadCmd->SetGuidance("name of packed input file");
+  fReadCmd->SetParameterName("filename", false); // required
+}
+
+void InPackedProducer::SetNewValue(G4UIcommand* command, G4String newValue)
+{
+  if (command == fReadCmd) {
+    if (!ReadEvents(newValue))
+      Log::Die("InPackedProducer: Error reading event tree from " + newValue);
+  }
+  else
+     Log::Die("InPackedProducer: Invalid unpack \"set\" command");
+}
+
+bool InPackedProducer::ReadEvents(G4String filename)
+{
+  // set up input tree
+  TChain* tree = new TChain("PackT");
+  if (!tree->Add(filename.c_str()))
+    return false;
+  DS::PackedRec* rec = new DS::PackedRec();
+  tree->SetBranchAddress("PackRec", &rec);
+
+  // holders for data that perists across many events
+  DS::TRIGInfo* currentTRIG = NULL;
+  DS::EPEDInfo* currentEPED = NULL;
+  DS::Run* currentRun = NULL;
+  bool runLevelDataIsSet = false;
+
+  // Loop over packed records
+  int irecord = 0;
+  while (irecord<tree->GetEntries() && !SignalHandler::IsTermRequested()) {
+    tree->GetEntry(irecord);
+    detail << "InPackedProducer: Processing record " << irecord << " (type " << rec->RecordType << ")" << newline;
+ 
+    switch (rec->RecordType) {
+      // EVENT: unpack DS::PackedEvent into DS::Root, run processor block
+      case Pack::RecordType::EVENT: {
+        DS::PackedEvent* pev = dynamic_cast<DS::PackedEvent*>(rec->Rec);
+        Log::Assert(pev, dformat("InPackedProducer: Encountered corrupted PackedEvent in record %i\n", irecord));
+
+        // some run-level data has to come from a PackedEvent
+        if (currentRun && !runLevelDataIsSet) {
+          currentRun->SetSubRunID(pev->SubRunID);
+          currentRun->SetMCFlag(pev->MCFlag);
+          currentRun->SetPackVer(pev->PackVer);
+          currentRun->SetDataType(pev->DataType);
+        }
+
+        DS::Root* ds = Pack::UnpackEvent(pev, currentTRIG, currentEPED);
+        fMainBlock->DSEvent(ds);
+        delete ds;
+        break;
+      }
+      // RHDR: unpack DS::RHDR to set up a new DS::Run
+      case Pack::RecordType::RHDR: {
+        DS::RHDR* rhdr = dynamic_cast<DS::RHDR*>(rec->Rec);
+        Log::Assert(rhdr, dformat("InPackedProducer: Encountered corrupted PackedEvent in record %i\n", irecord));
+        currentRun = Pack::UnpackRHDR(rhdr);
+        DS::RunStore::AddNewRun(currentRun);
+        runLevelDataIsSet = false;
+        break;
+      }
+      // CAAC: unpack DS::CAAC into this run's DS::AVStat
+      case Pack::RecordType::CAAC: {
+        DS::CAAC* caac = dynamic_cast<DS::CAAC*>(rec->Rec);
+        Log::Assert(caac, dformat("InPackedProducer: Encountered corrupted CAAC header in record %i\n", irecord));
+        DS::AVStat* avstat = currentRun->GetAVStat();
+	DS::AVStat* asUnpacked = Pack::UnpackCAAC(caac);
+        *avstat = *asUnpacked;
+	delete asUnpacked;
+        break;
+      }
+      // CAST: unpack DS::CAST into this run's DS::ManipStat
+      case Pack::RecordType::CAST: {
+        DS::CAST* cast = dynamic_cast<DS::CAST*>(rec->Rec);
+        Log::Assert(cast, dformat("InPackedProducer: Encountered corrupted CAST header in record %i\n", irecord));
+        DS::ManipStat* manipstat = currentRun->GetManipStat();
+	DS::ManipStat* msUnpacked = Pack::UnpackCAST(cast);
+        *manipstat = *msUnpacked;
+	delete msUnpacked;
+        break;
+      }
+      // TRIG: unpack DS::TRIG and set current TRIG header to apply to events
+      case Pack::RecordType::TRIG: {
+        delete currentTRIG;
+        DS::TRIG* trig = dynamic_cast<DS::TRIG*>(rec->Rec);
+        Log::Assert(trig, dformat("InPackedProducer: Encountered corrupted TRIG header in record %i\n", irecord));
+        currentTRIG = Pack::UnpackTRIG(trig);
+        break;
+      }
+      // EPED: unpack DS::EPED and set current EPED header to apply to events
+      case Pack::RecordType::EPED: {
+        delete currentEPED;
+        DS::EPED* eped = dynamic_cast<DS::EPED*>(rec->Rec);
+        Log::Assert(eped, dformat("InPackedProducer: Encountered corrupted EPED header in record %i\n", irecord));
+        currentEPED = Pack::UnpackEPED(eped);
+        break;
+      }
+      // default: unknown record type, file is probably corrupted
+      default:
+        Log::Die(dformat("InPackedProducer: Invalid record type %i for record %i\n", rec->RecordType, irecord));
+    }
+
+    irecord++;
+  }
+
+  return true;
+}
+
+} // namespace RAT
+
Index: src/io/DispatchEvents.cc
===================================================================
--- src/io/DispatchEvents.cc	(revision 0)
+++ src/io/DispatchEvents.cc	(revision 0)
@@ -0,0 +1,110 @@
+#include <RAT/Processor.hh>
+#include <RAT/Log.hh>
+
+#ifdef __ZMQ
+#include <RAT/DispatchEvents.hh>
+#include <RAT/Pack.hh>
+#include <RAT/DS/PackedEvent.hh>
+#include <RAT/DS/RunStore.hh>
+#include <RAT/DS/Run.hh>
+#include <RAT/DS/HeaderInfo.hh>
+
+#include <G4UImessenger.hh>
+
+namespace RAT {
+
+DispatchEvents::DispatchEvents() : Processor("DispatchEvents")
+{
+  serv = 0x0;
+  fSentRunHeaders = false;
+}
+
+DispatchEvents::~DispatchEvents()
+{
+  delete serv;
+}
+
+void DispatchEvents::SetS(std::string param, std::string value)
+{
+  if (param == "address") {
+    info << "DispatchEvents: Publishing to address " << value << newline;
+    serv = new avalanche::server(value);
+    Log::Assert(serv, "DispatchEvents: Unable to open socket");
+  }
+}
+
+Processor::Result DispatchEvents::DSEvent(DS::Root *ds)
+{
+  Log::Assert(serv, "DispatchEvents: Output address required");
+  DS::PackedRec* rec;
+
+  // If we're on the first event, fill the initial header information
+  if (!fSentRunHeaders) {
+    rec = Pack::MakeRunHeader(ds);
+    serv->sendObject(rec);
+    delete rec;
+  
+    // If AVStat / ManipStat are filled, make CAAC/CAST headers:
+    DS::Run* run = RAT::DS::RunStore::GetRun(ds);
+
+    if (run->ExistManipStat()) {
+      rec = Pack::MakeManipHeader(ds);
+      serv->sendObject(rec);
+      delete rec;
+    }
+
+    if (run->ExistAVStat()) {
+      rec = Pack::MakeAVHeader(ds);
+      serv->sendObject(rec);
+      delete rec;
+    }
+
+    fSentRunHeaders = true;
+  }
+  
+  // If this ds event has event-level info attached, make more headers
+  if (ds->ExistHeaderInfo()) {
+    if (ds->GetHeaderInfo()->ExistTRIGInfo()) {
+      rec = Pack::MakeTRIGHeader(ds);
+      serv->sendObject(rec);
+      delete rec;
+    }
+
+    if (ds->GetHeaderInfo()->ExistEPEDInfo()) {
+      rec = Pack::MakeEPEDHeader(ds);
+      serv->sendObject(rec);
+      delete rec;
+    }
+  }
+
+  // Loop over triggered events
+  for (int iev=0; iev<ds->GetEVCount(); iev++) {
+    rec = Pack::PackEvent(ds, iev);
+    serv->sendObject(rec);
+    delete rec;
+  }
+
+  return Processor::OK;
+}
+
+} // namespace RAT
+
+#else
+namespace RAT {
+
+class DispatchEvents : public Processor {
+public:
+  DispatchEvents();
+  virtual ~DispatchEvents() {};
+  virtual Processor::Result DSEvent(DS::Root* /*ds*/) {
+    return Processor::OK;
+  }
+};
+
+DispatchEvents::DispatchEvents() : Processor("DispatchEvents") {
+  Log::Die("DispatchEvents: Dispatcher requires ZeroMQ support (libzmq)");
+}
+
+} // namespace RAT
+#endif // __ZMQ
+
Index: src/io/Pack.hh
===================================================================
--- src/io/Pack.hh	(revision 0)
+++ src/io/Pack.hh	(revision 0)
@@ -0,0 +1,41 @@
+#ifndef __RAT_Pack___
+#define __RAT_Pack___
+
+#include <RAT/DS/Root.hh>
+#include <RAT/DS/PackedEvent.hh>
+
+namespace RAT {
+
+namespace Pack {
+  // version number
+  const int packVer = 0;
+
+  // record types
+  namespace RecordType {
+    enum { NONE, EVENT, RHDR, CAAC, CAST, TRIG, EPED };
+  }
+
+  // packing functions map full to packed DS
+  DS::PackedRec* MakeTRIGHeader(DS::Root* ds);
+  DS::PackedRec* MakeEPEDHeader(DS::Root* ds);
+  DS::PackedRec* MakeRunHeader(DS::Root* ds); 
+  DS::PackedRec* MakeAVHeader(DS::Root* ds);
+  DS::PackedRec* MakeManipHeader(DS::Root* ds);
+  DS::PackedRec* PackEvent(DS::Root* ds, int iev);
+  DS::PMTBundle MakePMTBundle(DS::PMTUnCal* pmt, unsigned int gtid);
+
+  // unpacking functions map packed to full DS
+  DS::Root* UnpackEvent(DS::PackedEvent* pev, DS::TRIGInfo* trig, DS::EPEDInfo* eped);
+  DS::Run* UnpackRHDR(DS::RHDR* rhdr);
+  DS::AVStat* UnpackCAAC(DS::CAAC* caac);
+  DS::ManipStat* UnpackCAST(DS::CAST* cast);
+  DS::TRIGInfo* UnpackTRIG(DS::TRIG* trig);
+  DS::EPEDInfo* UnpackEPED(DS::EPED* eped);
+  DS::PMTUnCal* UnpackPMT(DS::PMTBundle* bundle);
+
+} // namespace Pack
+
+} // namespace RAT
+
+#endif
+
Index: src/io/InDispatchProducer.cc
===================================================================
--- src/io/InDispatchProducer.cc	(revision 0)
+++ src/io/InDispatchProducer.cc	(revision 0)
@@ -0,0 +1,176 @@
+////////////////////////////////////////////////////////////////////
+// Last svn revision: $Id: UnPackEvents.cc 628 2011-10-17 16:53:43Z orebi $ 
+////////////////////////////////////////////////////////////////////
+
+#ifdef __ZMQ
+#include <RAT/InDispatchProducer.hh>
+#include <RAT/Pack.hh>
+#include <RAT/ProcBlock.hh>
+#include <RAT/DS/PackedEvent.hh>
+#include <RAT/DS/Root.hh>
+#include <RAT/DS/Run.hh>
+#include <RAT/DS/RunStore.hh>
+#include <RAT/SignalHandler.hh>
+#include <RAT/Log.hh>
+#include <RAT/DB.hh>
+
+#include <G4UIdirectory.hh>
+#include <G4UIcmdWithAString.hh>
+
+#include <TChain.h>
+
+#include <RAT/avalanche.hpp>
+
+namespace RAT {
+
+InDispatchProducer::InDispatchProducer(ProcBlock* block)
+{
+  SetMainBlock(block);
+
+  // build commands
+  G4UIdirectory* DebugDir = new G4UIdirectory("/rat/readdispatch/");
+  DebugDir->SetGuidance("Read events from the dispatcher stream");
+
+  // info message command
+  fReadCmd = new G4UIcmdWithAString("/rat/readdispatch/address", this);
+  fReadCmd->SetGuidance("address of dispatcher server");
+  fReadCmd->SetParameterName("address", false); // required
+}
+
+void InDispatchProducer::SetNewValue(G4UIcommand* command, G4String newValue)
+{
+  if (command == fReadCmd) {
+    if (!ReadEvents(newValue))
+      Log::Die("InDispatchProducer: Error reading events from server " + newValue);
+  }
+  else
+     Log::Die("InDispatchProducer: Invalid readdispatch \"set\" command");
+}
+
+bool InDispatchProducer::ReadEvents(G4String address)
+{
+  // set up client connection
+  avalanche::client* client = new avalanche::client(address);
+  info << "InDispatcherProducer: Listening to dispatcher at " << address << newline;
+
+  // holders for data that perists across many events
+  DS::TRIGInfo* currentTRIG = NULL;
+  DS::EPEDInfo* currentEPED = NULL;
+  DS::Run* currentRun = NULL;
+  bool runLevelDataIsSet = false;
+
+  // process records as they are received
+  while (!SignalHandler::IsTermRequested()) {
+    try {
+      RAT::DS::PackedRec* rec = NULL;
+      do {
+        rec = (RAT::DS::PackedRec*) client->recvObject(RAT::DS::PackedRec::Class(), ZMQ_NOBLOCK);
+      } while(rec == NULL);
+
+      detail << "InDispatchProducer: Received record of type " << rec->RecordType << newline;
+ 
+      switch (rec->RecordType) {
+        // EVENT: unpack DS::PackedEvent into DS::Root, run processor block
+        case Pack::RecordType::EVENT: {
+          DS::PackedEvent* pev = dynamic_cast<DS::PackedEvent*>(rec->Rec);
+          if (!pev) {
+            warn << "InDispatchProducer: Encountered corrupted PackedEvent" << newline;
+            continue;
+          }
+
+          // some run-level data has to come from a PackedEvent
+          if (currentRun && !runLevelDataIsSet) {
+            currentRun->SetSubRunID(pev->SubRunID);
+            currentRun->SetMCFlag(pev->MCFlag);
+            currentRun->SetPackVer(pev->PackVer);
+            currentRun->SetDataType(pev->DataType);
+          }
+
+          DS::Root* ds = Pack::UnpackEvent(pev, currentTRIG, currentEPED);
+          fMainBlock->DSEvent(ds);
+          delete ds;
+          break;
+        }
+        // RHDR: unpack DS::RHDR to set up a new DS::Run
+        case Pack::RecordType::RHDR: {
+          DS::RHDR* rhdr = dynamic_cast<DS::RHDR*>(rec->Rec);
+          if (!rhdr) {
+            warn << "InDispatchProducer: Encountered corrupted RHDR header" << newline;
+            continue;
+          }
+          currentRun = Pack::UnpackRHDR(rhdr);
+          DS::RunStore::AddNewRun(currentRun);
+          runLevelDataIsSet = false;
+          break;
+        }
+        // CAAC: unpack DS::CAAC into this run's DS::AVStat
+        case Pack::RecordType::CAAC: {
+          DS::CAAC* caac = dynamic_cast<DS::CAAC*>(rec->Rec);
+          if (!caac) {
+            warn << "InDispatchProducer: Encountered corrupted CAAC header" << newline;
+            continue;
+          }
+          DS::AVStat* avstat = currentRun->GetAVStat();
+	  DS::AVStat* asUnpacked = Pack::UnpackCAAC(caac);
+          *avstat = *asUnpacked;
+          delete asUnpacked;
+          break;
+        }
+        // CAST: unpack DS::CAST into this run's DS::ManipStat
+        case Pack::RecordType::CAST: {
+          DS::CAST* cast = dynamic_cast<DS::CAST*>(rec->Rec);
+          if (!cast) {
+            warn << "InDispatchProducer: Encountered corrupted CAST header" << newline;
+            continue;
+          }
+          DS::ManipStat* manipstat = currentRun->GetManipStat();
+          DS::ManipStat* msUnpacked = Pack::UnpackCAST(cast);
+          *manipstat = *msUnpacked;
+          delete msUnpacked;
+          break;
+        }
+        // TRIG: unpack DS::TRIG and set current TRIG header to apply to events
+        case Pack::RecordType::TRIG: {
+          delete currentTRIG;
+          DS::TRIG* trig = dynamic_cast<DS::TRIG*>(rec->Rec);
+          if (!trig) {
+            warn << "InDispatchProducer: Encountered corrupted TRIG header" << newline;
+            continue;
+          }
+          currentTRIG = Pack::UnpackTRIG(trig);
+          break;
+        }
+        // EPED: unpack DS::EPED and set current EPED header to apply to events
+        case Pack::RecordType::EPED: {
+          delete currentEPED;
+          DS::EPED* eped = dynamic_cast<DS::EPED*>(rec->Rec);
+          if (!eped) {
+            warn << "InDispatchProducer: Encountered corrupted EPED header" << newline;
+            continue;
+          }
+          currentEPED = Pack::UnpackEPED(eped);
+          break;
+        }
+        // default: unknown record type, packet is probably corrupted
+        default:
+          warn << "InDispatchProducer: Encountered invalid record type " << rec->RecordType << newline;
+      }
+    }
+    catch (zmq::error_t &e) {
+      // interrupts during zmq::recv sometimes generate exceptions
+      continue;
+    }
+    catch (...) {
+      warn << "InDispatchProducer: Caught signal in recv(), sending SIGINT to main..." << newline;
+      SignalHandler::SigInt();
+      break;
+    }
+  }
+
+  return true;
+}
+
+} // namespace RAT
+
+#endif
+
Index: src/core/Producer.hh
===================================================================
--- src/core/Producer.hh	(revision 650)
+++ src/core/Producer.hh	(working copy)
@@ -21,7 +21,7 @@
  *  your constructor so that users can start your producer running in
  *  their macros.  See InROOTProducer for an example of this.
  *  (Note that Gsim is a special producer which is wired into
- *  GEANT4'event management loop, so it is unusual in this respect.)
+ *  GEANT4's event management loop, so it is unusual in this respect.)
  *
  *  Another consideration for producers is graceful handling of a
  *  user's Ctrl-C termination request.  If a user presses Ctrl-C once,
@@ -40,7 +40,7 @@
 
  *  All producers will be constructed once in the main() function and
  *  destroyed at the end of program execution.  If you create a new
- *  Processor, be sure to edit main() accordingly.
+ *  Producer, be sure to edit main() accordingly.
  *  
  */
 
Index: src/geo/DetectorConstruction.cc
===================================================================
--- src/geo/DetectorConstruction.cc	(revision 650)
+++ src/geo/DetectorConstruction.cc	(working copy)
@@ -21,6 +21,8 @@
 namespace RAT 
 {
 
+std::vector<int> DetectorConstruction::fTubeStatus;
+std::vector<float> DetectorConstruction::fChanThresh;
 std::vector<float> DetectorConstruction::fChannelEff;
 double DetectorConstruction::fChannelEff_Ave;
 
@@ -69,6 +71,9 @@
       Log::Die("DetectorConstruction: Could not open veto geometry");
   }
 
+  DBLinkPtr fPMTInfo = DB::Get()->GetLink("PMTINFO");
+  fTubeStatus = fPMTInfo->GetIArray("type");
+
   // Construct the geometry
   GeoBuilder geo(fRun);
   fWorld = geo.ConstructAll();
@@ -91,13 +96,9 @@
   int fDQXX_info = fLdaq->GetI("dqxx_info");
   int fDQXX_expt = fLdaq->GetI("dqxx_expt");
 
-  DBLinkPtr fPMTInfo = DB::Get()->GetLink("PMTINFO");
-  std::vector<int> fTubeStatus;
-  fTubeStatus = fPMTInfo->GetIArray("type");
   int Ntubes = fTubeStatus.size();
   
   // GDOG: Calc channel thresholds directly from DQXX info
-  std::vector<float> fChanThresh;
   fChanThresh.resize(Ntubes);
   for(int np = 0; np < Ntubes; np++){
     fChanThresh[np] = fDQXX.GetThreshold(np);
Index: src/geo/DetectorConstruction.hh
===================================================================
--- src/geo/DetectorConstruction.hh	(revision 650)
+++ src/geo/DetectorConstruction.hh	(working copy)
@@ -59,6 +59,9 @@
   static double GetAveChanEfficiency();
   static void CalculateChannelEfficiencies();
 
+  static std::vector<int> fTubeStatus;
+  static std::vector<float> fChanThresh;
+
 protected:
   DS::Run *fRun;
   G4VPhysicalVolume* fWorld;
Index: config/EXTERNAL.scons
===================================================================
--- config/EXTERNAL.scons	(revision 650)
+++ config/EXTERNAL.scons	(working copy)
@@ -5,14 +5,12 @@
 import os.path
 import SCons
 
-
 ext_deps = {}
 
 ###############################################################
 #  EDIT BELOW IF YOU HAVE PROBLEMS WITH EXTERNAL DEPENDENCIES #
 ###############################################################
 
-
 # cURL 
 # If you want to define things manually comment the following
 # two lines and uncomment uncomment the other three
@@ -36,10 +34,8 @@
 ext_deps['bz2'] = {}
 ext_deps['bz2']['user'] = True
 ext_deps['bz2']['path'] = None
-ext_deps['bz2']['libs'] = "bz2" #shot form for -lbz2
+ext_deps['bz2']['libs'] = "bz2" # short form for -lbz2
 
-
-
 ###################################################################
 # DO NOT EDIT BELOW THIS POINT UNLESS YOU KNOW WHAT YOU ARE DOING #
 ###################################################################
Index: config/RAT.scons
===================================================================
--- config/RAT.scons	(revision 650)
+++ config/RAT.scons	(working copy)
@@ -89,9 +89,6 @@
 # failed in non-standard installations
 env.Append(**extopts)
 
-# Removed. Was superseded by the EXTERNAL.scons config file
-#env['LIBS'].extend(['-lcurl','-lbz2'])
-#env['LIBS'].extend(['-lbz2'])
 
 # Add flags from the shell environment
 user_controlled_vars = ['CPPFLAGS', 'CXXFLAGS', 'LDFLAGS']
@@ -108,10 +105,10 @@
 		envdict[envvar] = ARGUMENTS.get(envvar)
 env.Append(**envdict)
 
-
 # Add optional build flags
 # These use command line arguments:
 #  scons profile=1
+#  scons zmq=1
 #  scons debug=1
 #  scons opt=1
 #
@@ -129,6 +126,14 @@
 else:
     debugdefault = 0
 
+zmq = int(ARGUMENTS.get('zmq', 1)) == 1
+if zmq:
+    for key in os.environ['LIBPATH'].split(':'):
+        env.Append(LIBPATH=key)
+    if Configure(env).CheckLib('avalanche'):
+        env.Append(LIBS='avalanche')
+        env.Append(CPPFLAGS='-D__ZMQ')
+
 debug = int(ARGUMENTS.get('debug', debugdefault)) == 1
 if debug:
     env.Append(CXXFLAGS=arch['DEBUGFLAGS'])
Index: SConstruct
===================================================================
--- SConstruct	(revision 650)
+++ SConstruct	(working copy)
@@ -8,7 +8,7 @@
 
 modules = Split('''
 calib cmd core daq db fit fit/methods fit/optimisers fit/pdfs fit/selectors
-gen geo geo/PMT io physics physics/PMT stlplus util ''') # ds handled separately
+gen geo geo/PMT io physics physics/PMT stlplus util util/avalanche ''') # ds handled separately
 
 
 ############### You should not need to edit below this line ############
@@ -41,18 +41,18 @@
 cint_cls= Split('DS/Root DS/MC DS/EV DS/MCParticle DS/MCPhoton '
                 'DS/MCPMT DS/PMTCal DS/PMTUnCal DS/PMTTruth  '
                 'DS/PosFit DS/PosFitQPDF DS/PosFitFL '
-				'DS/FitResult DS/FitVertex '
+                'DS/FitResult DS/FitVertex '
                 'DS/SN DS/EFitQPDF '
-				'DS/Digitiser DS/TrigSum '
+                'DS/Digitiser DS/TrigSum '
                 'DS/EFitFL DS/VetoHit DS/MCHit ' 
                 'DS/MCSample DS/MCTrack DS/MCTrackStep DS/Calib '
                 'DS/RunStore DS/Run DS/PMTProperties '
-				'DS/StraightLinePath DS/GroupVelocityTime DS/EffectiveVelocityTime '
+                'DS/StraightLinePath DS/GroupVelocityTime DS/EffectiveVelocityTime '
                 'DSReader TrackNav TrackNode TrackCursor DB DBLink '
                 'DBTextLoader DBJsonLoader HTTPDownloader Log '
-				'DS/PackedEvent '
-				'DS/HeaderInfo DS/EPEDInfo DS/TRIGInfo '
-				'DS/AVStat DS/ManipStat BitManip '
+                'DS/PackedEvent '
+                'DS/HeaderInfo DS/EPEDInfo DS/TRIGInfo '
+                'DS/AVStat DS/ManipStat BitManip '
                 'DS/LinkDef ')
 cint_headers = ['include/RAT/' + clsname for clsname in cint_cls]
 
@@ -71,7 +71,7 @@
 cint_source = Split('ds/Root io/DSReader io/TrackNav io/TrackCursor '
                     'db/DB db/DBLink db/DBTextLoader db/DBTable util/BitManip '
                     'ds/RunStore db/DBJsonLoader '
-					'ds/StraightLinePath '
+                    'ds/StraightLinePath '
                     'util/ReadFile db/HTTPDownloader db/json_reader '
                     'db/json_writer db/json_value core/Log stlplus/fileio '
                     'stlplus/multiio stlplus/stringio stlplus/string_utilities '
Index: rat.cc
===================================================================
--- rat.cc	(revision 650)
+++ rat.cc	(working copy)
@@ -10,6 +10,7 @@
 /// REVISION HISTORY:\n
 ///     29 Mar 2010 : Gabriel Orebi Gann - add ``UnPackEvents''
 ///                   producer
+///     19 Dec 2011 : A Mastbaum - add InDispatchProducer
 ///
 /// \detail 
 ///
@@ -33,9 +34,6 @@
 
 #include <RAT/Log.hh>
 #include <RAT/RunManager.hh>
-#include <RAT/InROOTProducer.hh>
-#include <RAT/UnPackEvents.hh>
-#include <RAT/InNetProducer.hh>
 #include <RAT/ProcBlock.hh>
 #include <RAT/ProcBlockManager.hh>
 #include <RAT/SignalHandler.hh>
@@ -48,6 +46,12 @@
 #include <TStopwatch.h>
 #include <sys/utsname.h> //For uname()
 
+// event producers
+#include <RAT/InROOTProducer.hh>
+#include <RAT/InPackedProducer.hh>
+#include <RAT/InNetProducer.hh>
+#include <RAT/InDispatchProducer.hh>
+
 using namespace std;
 using namespace RAT;
 
@@ -131,9 +135,10 @@
       RunManager* runManager = new RunManager(mainBlock);
       gTheRunManager = runManager;
       info << BBLUE << "Initializing event producers..." << CLR << newline;
-      InROOTProducer *inroot = new InROOTProducer(mainBlock);
-      InNetProducer *innet = new InNetProducer(mainBlock);
-      UnPackEvents *unpack = new UnPackEvents(mainBlock);
+      InROOTProducer* inroot = new InROOTProducer(mainBlock);
+      InNetProducer* innet = new InNetProducer(mainBlock);
+      InPackedProducer* unpack = new InPackedProducer(mainBlock);
+      InDispatchProducer* indisp = new InDispatchProducer(mainBlock);
 
       // Setup signal handler to intercept Ctrl-C and quit event loop
       // nicely (closing files and all that).
@@ -200,6 +205,7 @@
       delete runManager;
       delete inroot;
       delete unpack;
+      delete indisp;
       delete innet;
 
       delete rdb_messenger;
